/**
 * Market Service
 *
 * Provides market data and analysis:
 * - Market info and discovery
 * - Orderbook data and analysis
 * - K-Line aggregation from trade data
 * - Spread analysis
 * - Arbitrage detection
 */
import { DataApiClient } from '../clients/data-api.js';
import { GammaApiClient, GammaMarket } from '../clients/gamma-api.js';
import type { UnifiedCache } from '../core/unified-cache.js';
import { RateLimiter } from '../core/rate-limiter.js';
import type { UnifiedMarket, ProcessedOrderbook, ArbitrageOpportunity, KLineInterval, KLineCandle, DualKLineData, RealtimeSpreadAnalysis, Side, Orderbook, UnderlyingAsset, TokenUnderlyingCorrelation } from '../core/types.js';
import type { BinanceService } from './binance-service.js';
export declare const POLYGON_MAINNET = 137;
export type { Side, Orderbook } from '../core/types.js';
export type PriceHistoryIntervalString = '1h' | '6h' | '1d' | '1w' | 'max';
export interface PriceHistoryParams {
    tokenId: string;
    interval?: PriceHistoryIntervalString;
    startTs?: number;
    endTs?: number;
    fidelity?: number;
}
export interface PricePoint {
    timestamp: number;
    price: number;
}
export interface MarketServiceConfig {
    /** Private key for CLOB client auth (optional, for authenticated endpoints) */
    privateKey?: string;
    /** Chain ID (default: Polygon mainnet 137) */
    chainId?: number;
}
/**
 * CLOB Market type (from CLOB API)
 *
 * This represents the raw market data from the CLOB API.
 * For merged market data with volume/liquidity, use UnifiedMarket from core/types.ts.
 */
export interface Market {
    conditionId: string;
    questionId?: string;
    marketSlug: string;
    question: string;
    description?: string;
    tokens: MarketToken[];
    active: boolean;
    closed: boolean;
    acceptingOrders: boolean;
    endDateIso?: string | null;
    negRisk?: boolean;
    minimumOrderSize?: number;
    minimumTickSize?: number;
}
/**
 * Token in a CLOB market
 * Same structure as MarketToken in core/types.ts
 */
export interface MarketToken {
    tokenId: string;
    outcome: string;
    price: number;
    winner?: boolean;
}
export declare class MarketService {
    private gammaApi;
    private dataApi;
    private rateLimiter;
    private cache;
    private config?;
    private binanceService?;
    private clobClient;
    private initialized;
    constructor(gammaApi: GammaApiClient | undefined, dataApi: DataApiClient | undefined, rateLimiter: RateLimiter, cache: UnifiedCache, config?: MarketServiceConfig | undefined, binanceService?: BinanceService | undefined);
    private ensureInitialized;
    /**
     * Get market from CLOB by condition ID
     */
    getClobMarket(conditionId: string): Promise<Market | null>;
    /**
     * Get multiple markets from CLOB
     */
    getClobMarkets(nextCursor?: string): Promise<{
        markets: Market[];
        nextCursor: string;
    }>;
    /**
     * Get orderbook for a single token
     */
    getTokenOrderbook(tokenId: string): Promise<Orderbook>;
    /**
     * Get orderbooks for multiple tokens
     */
    getTokenOrderbooks(params: Array<{
        tokenId: string;
        side: Side;
    }>): Promise<Map<string, Orderbook>>;
    /**
     * Get processed orderbook with arbitrage analysis for a market
     */
    getProcessedOrderbook(conditionId: string): Promise<ProcessedOrderbook>;
    /**
     * Get price history for a token
     */
    getPricesHistory(params: PriceHistoryParams): Promise<PricePoint[]>;
    /**
     * Get midpoint price for a token
     */
    getMidpoint(tokenId: string): Promise<number>;
    /**
     * Get spread for a token
     */
    getSpread(tokenId: string): Promise<number>;
    /**
     * Get last trade price for a token
     */
    getLastTradePrice(tokenId: string): Promise<number>;
    /**
     * Get market by slug or condition ID
     */
    getMarket(identifier: string): Promise<UnifiedMarket>;
    private getMarketBySlug;
    private getMarketByConditionId;
    /**
     * Get K-Line candles for a market (single token)
     *
     * @param conditionId - Market condition ID
     * @param interval - K-line interval (1s, 5s, 15s, 30s, 1m, 5m, 15m, 30m, 1h, 4h, 12h, 1d)
     * @param options - Query options
     * @param options.limit - Maximum number of trades to fetch for aggregation (default: 1000)
     * @param options.tokenId - Filter by specific token ID
     * @param options.outcomeIndex - Filter by outcome index (0 = primary, 1 = secondary)
     * @param options.startTimestamp - Start timestamp (Unix ms) - filter trades after this time
     * @param options.endTimestamp - End timestamp (Unix ms) - filter trades before this time
     *
     * @example
     * ```typescript
     * // Get 5s candles for the last 15 minutes
     * const now = Date.now();
     * const candles = await sdk.markets.getKLines(conditionId, '5s', {
     *   startTimestamp: now - 15 * 60 * 1000,
     *   endTimestamp: now,
     * });
     * ```
     */
    getKLines(conditionId: string, interval: KLineInterval, options?: {
        limit?: number;
        tokenId?: string;
        outcomeIndex?: number;
        startTimestamp?: number;
        endTimestamp?: number;
    }): Promise<KLineCandle[]>;
    /**
     * Get dual K-Lines (YES + NO tokens)
     *
     * @param conditionId - Market condition ID
     * @param interval - K-line interval (1s, 5s, 15s, 30s, 1m, 5m, 15m, 30m, 1h, 4h, 12h, 1d)
     * @param options - Query options
     * @param options.limit - Maximum number of trades to fetch for aggregation (default: 1000)
     * @param options.startTimestamp - Start timestamp (Unix ms) - filter trades after this time
     * @param options.endTimestamp - End timestamp (Unix ms) - filter trades before this time
     *
     * @example
     * ```typescript
     * // Get 15s dual K-lines for a 15-minute market
     * const now = Date.now();
     * const data = await sdk.markets.getDualKLines(conditionId, '15s', {
     *   startTimestamp: now - 15 * 60 * 1000,
     *   endTimestamp: now,
     * });
     * console.log(`Up candles: ${data.yes.length}, Down candles: ${data.no.length}`);
     * ```
     */
    getDualKLines(conditionId: string, interval: KLineInterval, options?: {
        limit?: number;
        startTimestamp?: number;
        endTimestamp?: number;
    }): Promise<DualKLineData>;
    /**
     * Get aligned K-line data for token and underlying asset
     *
     * This method fetches K-line data from both Polymarket (token prices)
     * and Binance (underlying asset prices), aligns them by timestamp,
     * and optionally calculates Pearson correlation coefficients.
     *
     * @param conditionId - Market condition ID
     * @param underlying - Underlying asset (BTC, ETH, SOL)
     * @param interval - K-line interval (must be supported by both Poly and Binance)
     * @param options - Optional parameters
     * @returns Aligned data with optional correlation coefficients
     *
     * @example
     * ```typescript
     * const data = await marketService.getTokenUnderlyingData(
     *   '0x123...',
     *   'BTC',
     *   '1h',
     *   { limit: 100, calculateCorrelation: true }
     * );
     *
     * // Access aligned data
     * for (const point of data.data) {
     *   console.log(`${point.timestamp}: Up=${point.upPrice}, BTC=${point.underlyingPrice}`);
     * }
     *
     * // Check correlation
     * if (data.correlation) {
     *   console.log(`Correlation: ${data.correlation.upVsUnderlying}`);
     * }
     * ```
     */
    getTokenUnderlyingData(conditionId: string, underlying: UnderlyingAsset, interval: KLineInterval, options?: {
        limit?: number;
        calculateCorrelation?: boolean;
    }): Promise<TokenUnderlyingCorrelation>;
    /**
     * Find the nearest available price for a timestamp
     */
    private findNearestPrice;
    /**
     * Calculate Pearson correlation coefficients
     */
    private calculatePearsonCorrelation;
    /**
     * Calculate Pearson correlation coefficient between two arrays
     * Returns a value between -1 and 1
     */
    private pearson;
    /**
     * Aggregate trades into K-Line candles
     *
     * Note: Polymarket API may return timestamps in seconds or milliseconds.
     * This function normalizes all timestamps to milliseconds for consistent handling.
     */
    private aggregateToKLines;
    /**
     * Analyze historical spread from trade close prices (for backtesting)
     *
     * This uses trade close prices, not orderbook bid/ask.
     * Useful for:
     * - Historical analysis / backtesting
     * - Understanding past price movements
     * - Identifying patterns when orderbook data unavailable
     */
    private analyzeHistoricalSpread;
    /**
     * Calculate real-time spread from orderbook (for live trading)
     *
     * This uses orderbook bid/ask prices for accurate arbitrage detection.
     * Useful for:
     * - Real-time arbitrage execution
     * - Live trading decisions
     * - Accurate profit calculations
     */
    private calculateRealtimeSpread;
    /**
     * Get real-time spread analysis only (without K-lines)
     * Use this for quick arbitrage checks
     */
    getRealtimeSpread(conditionId: string): Promise<RealtimeSpreadAnalysis>;
    /**
     * Get processed orderbook with analytics (alias for getProcessedOrderbook)
     */
    getOrderbook(conditionId: string): Promise<ProcessedOrderbook>;
    /**
     * Detect arbitrage opportunity
     *
     * 使用有效价格（考虑镜像订单）计算套利机会
     * 详细原理见: docs/01-polymarket-orderbook-arbitrage.md
     */
    detectArbitrage(conditionId: string, threshold?: number): Promise<ArbitrageOpportunity | null>;
    /**
     * Get trending markets
     */
    getTrendingMarkets(limit?: number): Promise<GammaMarket[]>;
    /**
     * Search markets
     */
    searchMarkets(params: {
        active?: boolean;
        closed?: boolean;
        limit?: number;
        offset?: number;
        order?: string;
    }): Promise<GammaMarket[]>;
    /**
     * Scan for short-term crypto markets (Up/Down markets ending soon)
     *
     * ## Market Types
     * Polymarket has short-term crypto markets in two durations:
     * - **5-minute markets**: slug pattern `{coin}-updown-5m-{timestamp}`
     * - **15-minute markets**: slug pattern `{coin}-updown-15m-{timestamp}`
     *
     * ## Slug Pattern
     * The timestamp in the slug is the START time of the time window:
     * - 15-minute markets: `{coin}-updown-15m-{Math.floor(startTime / 900) * 900}`
     * - 5-minute markets: `{coin}-updown-5m-{Math.floor(startTime / 300) * 300}`
     *
     * Example: `btc-updown-15m-1767456000` starts at 1767456000 (16:00:00 UTC)
     * and ends 15 minutes later at 1767456900 (16:15:00 UTC)
     *
     * ## Supported Coins
     * - BTC (Bitcoin)
     * - ETH (Ethereum)
     * - SOL (Solana)
     * - XRP (Ripple)
     *
     * ## Market Lifecycle Rules
     * 1. Markets are created ahead of time (before they become tradeable)
     * 2. New markets may not have prices yet (show 0.5/0.5)
     * 3. When one market ends, the next one is already open for trading
     * 4. A market ending doesn't mean no price - it means resolution is pending
     *
     * ## Outcomes
     * All crypto short-term markets have:
     * - outcomes: ["Up", "Down"]
     * - Resolution based on price movement during the time window
     *
     * @param options - Scan options
     * @param options.minMinutesUntilEnd - Minimum minutes until market ends (default: 5)
     * @param options.maxMinutesUntilEnd - Maximum minutes until market ends (default: 60)
     * @param options.limit - Maximum number of markets to return (default: 20)
     * @param options.sortBy - Sort field: 'endDate' | 'volume' | 'liquidity' (default: 'endDate')
     * @param options.duration - Filter by duration: '5m' | '15m' | 'all' (default: 'all')
     * @param options.coin - Filter by coin: 'BTC' | 'ETH' | 'SOL' | 'XRP' | 'all' (default: 'all')
     * @returns Array of crypto short-term markets
     *
     * @example
     * ```typescript
     * // Find all 15-minute markets ending in 5-30 minutes
     * const markets = await sdk.markets.scanCryptoShortTermMarkets({
     *   minMinutesUntilEnd: 5,
     *   maxMinutesUntilEnd: 30,
     *   duration: '15m',
     * });
     *
     * // Find BTC 5-minute markets only
     * const btcMarkets = await sdk.markets.scanCryptoShortTermMarkets({
     *   coin: 'BTC',
     *   duration: '5m',
     * });
     * ```
     */
    scanCryptoShortTermMarkets(options?: {
        minMinutesUntilEnd?: number;
        maxMinutesUntilEnd?: number;
        limit?: number;
        sortBy?: 'endDate' | 'volume' | 'liquidity';
        duration?: '5m' | '15m' | 'all';
        coin?: 'BTC' | 'ETH' | 'SOL' | 'XRP' | 'all';
    }): Promise<GammaMarket[]>;
    /**
     * Detect market signals (volume surge, depth imbalance, whale trades)
     */
    detectMarketSignals(conditionId: string): Promise<Array<{
        type: 'volume_surge' | 'depth_imbalance' | 'whale_trade' | 'momentum';
        severity: 'low' | 'medium' | 'high';
        details: Record<string, unknown>;
    }>>;
    private normalizeClobMarket;
    private processOrderbooks;
    private mergeMarkets;
    private fromGammaMarket;
    private fromClobMarket;
}
export declare function getIntervalMs(interval: KLineInterval): number;
//# sourceMappingURL=market-service.d.ts.map