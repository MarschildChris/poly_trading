/**
 * DipArbService - Dip Arbitrage Service
 *
 * 暴跌套利服务 - 针对 Polymarket 15分钟/5分钟 UP/DOWN 市场
 *
 * 策略原理：
 * 1. 每个市场有一个 "price to beat"（开盘时的 Chainlink 价格）
 * 2. 结算规则：
 *    - UP 赢：结束时价格 >= price to beat
 *    - DOWN 赢：结束时价格 < price to beat
 *
 * 3. 套利流程：
 *    - Leg1：检测暴跌 → 买入暴跌侧
 *    - Leg2：等待对冲条件 → 买入另一侧
 *    - 利润：总成本 < $1 时获得无风险利润
 *
 * 使用示例：
 * ```typescript
 * const sdk = await PolymarketSDK.create({ privateKey: '...' });
 *
 * // 自动找到并启动
 * await sdk.dipArb.findAndStart({ coin: 'BTC' });
 *
 * // 监听信号
 * sdk.dipArb.on('signal', (signal) => {
 *   console.log(`Signal: ${signal.type} ${signal.side}`);
 * });
 * ```
 */
import { EventEmitter } from 'events';
import { CTFClient } from '../clients/ctf-client.js';
import { DEFAULT_DIP_ARB_CONFIG, DEFAULT_AUTO_ROTATE_CONFIG, createDipArbInitialStats, createDipArbRoundState, calculateDipArbProfitRate, estimateUpWinRate, detectMispricing, parseUnderlyingFromSlug, parseDurationFromSlug, isDipArbLeg1Signal, } from './dip-arb-types.js';
// ===== DipArbService =====
export class DipArbService extends EventEmitter {
    // Dependencies
    realtimeService;
    tradingService = null;
    marketService;
    ctf = null;
    // Configuration
    config;
    autoRotateConfig;
    // State
    market = null;
    currentRound = null;
    isRunning = false;
    isExecuting = false;
    lastExecutionTime = 0;
    stats;
    // Subscriptions
    marketSubscription = null;
    chainlinkSubscription = null;
    // Auto-rotate state
    rotateCheckInterval = null;
    nextMarket = null;
    // Pending redemption state (for background redemption after market resolution)
    pendingRedemptions = [];
    redeemCheckInterval = null;
    // Orderbook state
    upAsks = [];
    downAsks = [];
    // Price history for sliding window detection
    // Each entry: { timestamp: number, upAsk: number, downAsk: number }
    priceHistory = [];
    MAX_HISTORY_LENGTH = 100; // Keep last 100 price points
    // Price state
    currentUnderlyingPrice = 0;
    // Signal state - prevent duplicate signals within same round
    leg1SignalEmitted = false;
    constructor(realtimeService, tradingService, marketService, privateKey, chainId = 137) {
        super();
        this.realtimeService = realtimeService;
        this.tradingService = tradingService;
        this.marketService = marketService;
        // Initialize with default config
        this.config = { ...DEFAULT_DIP_ARB_CONFIG };
        this.autoRotateConfig = { ...DEFAULT_AUTO_ROTATE_CONFIG };
        this.stats = createDipArbInitialStats();
        // Initialize CTF if private key provided
        if (privateKey) {
            this.ctf = new CTFClient({
                privateKey,
                rpcUrl: 'https://polygon-rpc.com',
                chainId,
            });
        }
    }
    // ===== Public API: Configuration =====
    /**
     * Update configuration
     */
    updateConfig(config) {
        this.config = {
            ...this.config,
            ...config,
        };
        this.log(`Config updated: ${JSON.stringify(config)}`);
    }
    /**
     * Get current configuration
     */
    getConfig() {
        return { ...this.config };
    }
    // ===== Public API: Market Discovery =====
    /**
     * Scan for upcoming UP/DOWN markets
     *
     * Uses MarketService.scanCryptoShortTermMarkets()
     */
    async scanUpcomingMarkets(options = {}) {
        const { coin = 'all', duration = 'all', minMinutesUntilEnd = 5, maxMinutesUntilEnd = 60, limit = 20, } = options;
        try {
            const gammaMarkets = await this.marketService.scanCryptoShortTermMarkets({
                coin: coin,
                duration: duration,
                minMinutesUntilEnd,
                maxMinutesUntilEnd,
                limit,
                sortBy: 'endDate',
            });
            // Get full market info with token IDs for each market
            const results = [];
            for (const gm of gammaMarkets) {
                // Retry up to 3 times for network errors
                let retries = 3;
                while (retries > 0) {
                    try {
                        // Get full market info from CLOB API via MarketService
                        const market = await this.marketService.getMarket(gm.conditionId);
                        // Find UP and DOWN tokens
                        const upToken = market.tokens.find(t => t.outcome.toLowerCase() === 'up' || t.outcome.toLowerCase() === 'yes');
                        const downToken = market.tokens.find(t => t.outcome.toLowerCase() === 'down' || t.outcome.toLowerCase() === 'no');
                        if (upToken?.tokenId && downToken?.tokenId) {
                            results.push({
                                name: gm.question,
                                slug: gm.slug,
                                conditionId: gm.conditionId,
                                upTokenId: upToken.tokenId,
                                downTokenId: downToken.tokenId,
                                underlying: parseUnderlyingFromSlug(gm.slug),
                                durationMinutes: parseDurationFromSlug(gm.slug),
                                endTime: gm.endDate,
                            });
                        }
                        break; // Success, exit retry loop
                    }
                    catch (error) {
                        retries--;
                        if (retries > 0) {
                            // Wait 1 second before retry
                            await new Promise(r => setTimeout(r, 1000));
                        }
                    }
                }
            }
            return results;
        }
        catch (error) {
            this.emit('error', error instanceof Error ? error : new Error(String(error)));
            return [];
        }
    }
    /**
     * Find the best market and start monitoring
     */
    async findAndStart(options = {}) {
        const { coin, preferDuration = '15m' } = options;
        const scanOptions = {
            coin: coin || 'all',
            duration: preferDuration,
            minMinutesUntilEnd: 10,
            maxMinutesUntilEnd: 60,
            limit: 10,
        };
        const markets = await this.scanUpcomingMarkets(scanOptions);
        if (markets.length === 0) {
            this.log('No suitable markets found');
            return null;
        }
        // Find the best market (prefer specified coin, then by time)
        let bestMarket = markets[0];
        if (coin) {
            const coinMarket = markets.find(m => m.underlying === coin);
            if (coinMarket) {
                bestMarket = coinMarket;
            }
        }
        await this.start(bestMarket);
        return bestMarket;
    }
    // ===== Public API: Lifecycle =====
    /**
     * Start monitoring a market
     */
    async start(market) {
        if (this.isRunning) {
            throw new Error('DipArbService is already running. Call stop() first.');
        }
        // Validate token IDs
        if (!market.upTokenId || !market.downTokenId) {
            throw new Error(`Invalid market config: missing token IDs. upTokenId=${market.upTokenId}, downTokenId=${market.downTokenId}`);
        }
        this.market = market;
        this.isRunning = true;
        this.stats = createDipArbInitialStats();
        this.priceHistory = []; // Clear price history for new market
        this.log(`Starting Dip Arb monitor for: ${market.name}`);
        this.log(`Condition ID: ${market.conditionId.slice(0, 20)}...`);
        this.log(`Underlying: ${market.underlying}`);
        this.log(`Duration: ${market.durationMinutes}m`);
        this.log(`Auto Execute: ${this.config.autoExecute ? 'YES' : 'NO'}`);
        // Initialize trading service if available
        if (this.tradingService) {
            try {
                await this.tradingService.initialize();
                this.log(`Wallet: ${this.ctf?.getAddress()}`);
            }
            catch (error) {
                this.log(`Warning: Trading service init failed: ${error}`);
            }
        }
        else {
            this.log('No wallet configured - monitoring only');
        }
        // Connect realtime service and wait for connection
        this.realtimeService.connect();
        // Wait for WebSocket connection (with timeout)
        await new Promise((resolve) => {
            const timeout = setTimeout(() => {
                this.log('Warning: WebSocket connection timeout, proceeding anyway');
                resolve();
            }, 10000);
            // Check if already connected
            if (this.realtimeService.isConnected?.()) {
                clearTimeout(timeout);
                resolve();
                return;
            }
            this.realtimeService.once('connected', () => {
                clearTimeout(timeout);
                this.log('WebSocket connected');
                resolve();
            });
        });
        // Subscribe to market orderbook
        this.log(`Subscribing to tokens: UP=${market.upTokenId.slice(0, 20)}..., DOWN=${market.downTokenId.slice(0, 20)}...`);
        this.marketSubscription = this.realtimeService.subscribeMarkets([market.upTokenId, market.downTokenId], {
            onOrderbook: (book) => {
                if (this.config.debug) {
                    const bookTokenId = book.tokenId || book.assetId;
                    const tokenType = bookTokenId === market.upTokenId ? 'UP' :
                        bookTokenId === market.downTokenId ? 'DOWN' : 'UNKNOWN';
                    const bestAsk = book.asks[0]?.price ?? 'N/A';
                    this.log(`Orderbook [${tokenType}]: asks=${book.asks.length}, bestAsk=${bestAsk}`);
                }
                this.handleOrderbookUpdate(book);
            },
            onError: (error) => this.emit('error', error),
        });
        // Subscribe to Chainlink prices for the underlying asset
        // Format: ETH -> ETH/USD
        const chainlinkSymbol = `${market.underlying}/USD`;
        console.log(`[DipArb] Subscribing to Chainlink prices: ${chainlinkSymbol}`);
        this.chainlinkSubscription = this.realtimeService.subscribeCryptoChainlinkPrices([chainlinkSymbol], {
            onPrice: (price) => {
                console.log(`[DipArb] Chainlink price received: ${price.symbol} = $${price.price}`);
                this.handleChainlinkPriceUpdate(price);
            },
        });
        this.emit('started', market);
        this.log('Monitoring for dip arbitrage opportunities...');
    }
    /**
     * Stop monitoring
     */
    async stop() {
        if (!this.isRunning)
            return;
        this.isRunning = false;
        // Stop rotate check
        this.stopRotateCheck();
        // Unsubscribe
        if (this.marketSubscription) {
            this.marketSubscription.unsubscribe();
            this.marketSubscription = null;
        }
        if (this.chainlinkSubscription) {
            this.chainlinkSubscription.unsubscribe();
            this.chainlinkSubscription = null;
        }
        // Update stats
        this.stats.runningTimeMs = Date.now() - this.stats.startTime;
        this.log('Stopped');
        this.log(`Rounds monitored: ${this.stats.roundsMonitored}`);
        this.log(`Rounds completed: ${this.stats.roundsSuccessful}`);
        this.log(`Total profit: $${this.stats.totalProfit.toFixed(2)}`);
        this.emit('stopped');
    }
    /**
     * Check if service is running
     */
    isActive() {
        return this.isRunning;
    }
    /**
     * Get current market
     */
    getMarket() {
        return this.market;
    }
    // ===== Public API: State Access =====
    /**
     * Get statistics
     */
    getStats() {
        return {
            ...this.stats,
            runningTimeMs: this.isRunning ? Date.now() - this.stats.startTime : this.stats.runningTimeMs,
            currentRound: this.currentRound ? {
                roundId: this.currentRound.roundId,
                phase: this.currentRound.phase,
                priceToBeat: this.currentRound.priceToBeat,
                leg1: this.currentRound.leg1 ? {
                    side: this.currentRound.leg1.side,
                    price: this.currentRound.leg1.price,
                } : undefined,
            } : undefined,
        };
    }
    /**
     * Get current round state
     */
    getCurrentRound() {
        return this.currentRound ? { ...this.currentRound } : null;
    }
    /**
     * Get current price to beat
     */
    getPriceToBeat() {
        return this.currentRound?.priceToBeat ?? null;
    }
    // ===== Public API: Manual Execution =====
    /**
     * Execute Leg1 trade
     */
    async executeLeg1(signal) {
        const startTime = Date.now();
        if (!this.tradingService || !this.market || !this.currentRound) {
            return {
                success: false,
                leg: 'leg1',
                roundId: signal.roundId,
                error: 'Trading service not available or no active round',
                executionTimeMs: Date.now() - startTime,
            };
        }
        try {
            this.isExecuting = true;
            // 计算拆分订单参数
            const splitCount = Math.max(1, this.config.splitOrders);
            const sharesPerOrder = signal.shares / splitCount;
            const amountPerOrder = sharesPerOrder * signal.targetPrice;
            // 检查每笔订单是否满足最小金额要求
            if (amountPerOrder < 1) {
                return {
                    success: false,
                    leg: 'leg1',
                    roundId: signal.roundId,
                    error: `Order amount ($${amountPerOrder.toFixed(2)}) is below Polymarket minimum ($1)`,
                    executionTimeMs: Date.now() - startTime,
                };
            }
            let totalSharesFilled = 0;
            let totalAmountSpent = 0;
            let lastOrderId;
            let failedOrders = 0;
            // 执行多笔订单
            for (let i = 0; i < splitCount; i++) {
                const orderParams = {
                    tokenId: signal.tokenId,
                    side: 'BUY',
                    amount: amountPerOrder,
                };
                if (this.config.debug && splitCount > 1) {
                    this.log(`Leg1 order ${i + 1}/${splitCount}: ${sharesPerOrder.toFixed(2)} shares @ ${signal.targetPrice.toFixed(4)}`);
                }
                const result = await this.tradingService.createMarketOrder(orderParams);
                if (result.success) {
                    totalSharesFilled += sharesPerOrder;
                    totalAmountSpent += amountPerOrder;
                    lastOrderId = result.orderId;
                }
                else {
                    failedOrders++;
                    this.log(`Leg1 order ${i + 1}/${splitCount} failed: ${result.errorMsg}`);
                }
                // 订单间隔
                if (i < splitCount - 1 && this.config.orderIntervalMs > 0) {
                    await new Promise(resolve => setTimeout(resolve, this.config.orderIntervalMs));
                }
            }
            // 至少有一笔成功
            if (totalSharesFilled > 0) {
                const avgPrice = totalAmountSpent / totalSharesFilled;
                // Record leg1 fill
                this.currentRound.leg1 = {
                    side: signal.dipSide,
                    price: avgPrice,
                    shares: totalSharesFilled,
                    timestamp: Date.now(),
                    tokenId: signal.tokenId,
                };
                this.currentRound.phase = 'leg1_filled';
                this.stats.leg1Filled++;
                this.lastExecutionTime = Date.now();
                if (splitCount > 1) {
                    this.log(`Leg1 completed: ${splitCount - failedOrders}/${splitCount} orders filled, total ${totalSharesFilled.toFixed(2)} shares`);
                }
                return {
                    success: true,
                    leg: 'leg1',
                    roundId: signal.roundId,
                    side: signal.dipSide,
                    price: avgPrice,
                    shares: totalSharesFilled,
                    orderId: lastOrderId,
                    executionTimeMs: Date.now() - startTime,
                };
            }
            else {
                return {
                    success: false,
                    leg: 'leg1',
                    roundId: signal.roundId,
                    error: 'All orders failed',
                    executionTimeMs: Date.now() - startTime,
                };
            }
        }
        catch (error) {
            return {
                success: false,
                leg: 'leg1',
                roundId: signal.roundId,
                error: error instanceof Error ? error.message : String(error),
                executionTimeMs: Date.now() - startTime,
            };
        }
        finally {
            this.isExecuting = false;
        }
    }
    /**
     * Execute Leg2 trade
     */
    async executeLeg2(signal) {
        const startTime = Date.now();
        if (!this.tradingService || !this.market || !this.currentRound) {
            return {
                success: false,
                leg: 'leg2',
                roundId: signal.roundId,
                error: 'Trading service not available or no active round',
                executionTimeMs: Date.now() - startTime,
            };
        }
        try {
            this.isExecuting = true;
            // 计算拆分订单参数
            const splitCount = Math.max(1, this.config.splitOrders);
            const sharesPerOrder = signal.shares / splitCount;
            const amountPerOrder = sharesPerOrder * signal.targetPrice;
            // 检查每笔订单是否满足最小金额要求
            if (amountPerOrder < 1) {
                return {
                    success: false,
                    leg: 'leg2',
                    roundId: signal.roundId,
                    error: `Order amount ($${amountPerOrder.toFixed(2)}) is below Polymarket minimum ($1)`,
                    executionTimeMs: Date.now() - startTime,
                };
            }
            let totalSharesFilled = 0;
            let totalAmountSpent = 0;
            let lastOrderId;
            let failedOrders = 0;
            // 执行多笔订单
            for (let i = 0; i < splitCount; i++) {
                const orderParams = {
                    tokenId: signal.tokenId,
                    side: 'BUY',
                    amount: amountPerOrder,
                };
                if (this.config.debug && splitCount > 1) {
                    this.log(`Leg2 order ${i + 1}/${splitCount}: ${sharesPerOrder.toFixed(2)} shares @ ${signal.targetPrice.toFixed(4)}`);
                }
                const result = await this.tradingService.createMarketOrder(orderParams);
                if (result.success) {
                    totalSharesFilled += sharesPerOrder;
                    totalAmountSpent += amountPerOrder;
                    lastOrderId = result.orderId;
                }
                else {
                    failedOrders++;
                    this.log(`Leg2 order ${i + 1}/${splitCount} failed: ${result.errorMsg}`);
                }
                // 订单间隔
                if (i < splitCount - 1 && this.config.orderIntervalMs > 0) {
                    await new Promise(resolve => setTimeout(resolve, this.config.orderIntervalMs));
                }
            }
            // 至少有一笔成功
            if (totalSharesFilled > 0) {
                const avgPrice = totalAmountSpent / totalSharesFilled;
                const leg1Price = this.currentRound.leg1?.price || 0;
                const actualTotalCost = leg1Price + avgPrice;
                // Record leg2 fill
                this.currentRound.leg2 = {
                    side: signal.hedgeSide,
                    price: avgPrice,
                    shares: totalSharesFilled,
                    timestamp: Date.now(),
                    tokenId: signal.tokenId,
                };
                this.currentRound.phase = 'completed';
                this.currentRound.totalCost = actualTotalCost;
                this.currentRound.profit = 1 - actualTotalCost;
                this.stats.leg2Filled++;
                this.stats.roundsSuccessful++;
                this.stats.totalProfit += this.currentRound.profit * totalSharesFilled;
                this.stats.totalSpent += actualTotalCost * totalSharesFilled;
                this.lastExecutionTime = Date.now();
                if (splitCount > 1) {
                    this.log(`Leg2 completed: ${splitCount - failedOrders}/${splitCount} orders filled, total ${totalSharesFilled.toFixed(2)} shares`);
                }
                const roundResult = {
                    roundId: signal.roundId,
                    status: 'completed',
                    leg1: this.currentRound.leg1,
                    leg2: this.currentRound.leg2,
                    totalCost: this.currentRound.totalCost,
                    profit: this.currentRound.profit,
                    profitRate: calculateDipArbProfitRate(this.currentRound.totalCost),
                    merged: false,
                };
                this.emit('roundComplete', roundResult);
                // Auto merge if enabled
                if (this.config.autoMerge) {
                    const mergeResult = await this.merge();
                    roundResult.merged = mergeResult.success;
                    roundResult.mergeTxHash = mergeResult.txHash;
                }
                return {
                    success: true,
                    leg: 'leg2',
                    roundId: signal.roundId,
                    side: signal.hedgeSide,
                    price: avgPrice,
                    shares: totalSharesFilled,
                    orderId: lastOrderId,
                    executionTimeMs: Date.now() - startTime,
                };
            }
            else {
                return {
                    success: false,
                    leg: 'leg2',
                    roundId: signal.roundId,
                    error: 'All orders failed',
                    executionTimeMs: Date.now() - startTime,
                };
            }
        }
        catch (error) {
            return {
                success: false,
                leg: 'leg2',
                roundId: signal.roundId,
                error: error instanceof Error ? error.message : String(error),
                executionTimeMs: Date.now() - startTime,
            };
        }
        finally {
            this.isExecuting = false;
        }
    }
    /**
     * Merge YES + NO tokens to USDC
     */
    async merge() {
        const startTime = Date.now();
        const roundId = this.currentRound?.roundId || 'unknown';
        if (!this.ctf || !this.market || !this.currentRound) {
            return {
                success: false,
                leg: 'merge',
                roundId,
                error: 'CTF client not available or no completed round',
                executionTimeMs: Date.now() - startTime,
            };
        }
        const shares = Math.min(this.currentRound.leg1?.shares || 0, this.currentRound.leg2?.shares || 0);
        if (shares <= 0) {
            return {
                success: false,
                leg: 'merge',
                roundId,
                error: 'No shares to merge',
                executionTimeMs: Date.now() - startTime,
            };
        }
        try {
            const result = await this.ctf.merge(this.market.conditionId, shares.toString());
            return {
                success: result.success,
                leg: 'merge',
                roundId,
                shares,
                txHash: result.txHash,
                executionTimeMs: Date.now() - startTime,
            };
        }
        catch (error) {
            return {
                success: false,
                leg: 'merge',
                roundId,
                error: error instanceof Error ? error.message : String(error),
                executionTimeMs: Date.now() - startTime,
            };
        }
    }
    // ===== Private: Event Handlers =====
    handleOrderbookUpdate(book) {
        if (!this.market)
            return;
        // Determine which side this update is for
        const tokenId = book.tokenId;
        const isUpToken = tokenId === this.market.upTokenId;
        const isDownToken = tokenId === this.market.downTokenId;
        // OrderbookLevel has price and size as numbers
        if (isUpToken) {
            this.upAsks = book.asks.map(l => ({ price: l.price, size: l.size }));
        }
        else if (isDownToken) {
            this.downAsks = book.asks.map(l => ({ price: l.price, size: l.size }));
        }
        // Record price history for sliding window detection
        this.recordPriceHistory();
        // Check if we need to start a new round (async but fire-and-forget to not block orderbook updates)
        this.checkAndStartNewRound().catch(err => {
            this.emit('error', err instanceof Error ? err : new Error(String(err)));
        });
        // Detect signals
        const signal = this.detectSignal();
        if (signal) {
            this.handleSignal(signal);
        }
    }
    /**
     * Record current prices to history buffer for sliding window detection
     */
    recordPriceHistory() {
        const upAsk = this.upAsks[0]?.price ?? 0;
        const downAsk = this.downAsks[0]?.price ?? 0;
        // Only record if we have valid prices
        if (upAsk <= 0 || downAsk <= 0)
            return;
        this.priceHistory.push({
            timestamp: Date.now(),
            upAsk,
            downAsk,
        });
        // Trim history to max length
        if (this.priceHistory.length > this.MAX_HISTORY_LENGTH) {
            this.priceHistory = this.priceHistory.slice(-this.MAX_HISTORY_LENGTH);
        }
    }
    /**
     * Get price from N milliseconds ago for sliding window detection
     *
     * @param side - 'UP' or 'DOWN'
     * @param msAgo - Milliseconds ago (e.g., 3000 for 3 seconds)
     * @returns Price from that time, or null if not available
     */
    getPriceFromHistory(side, msAgo) {
        const targetTime = Date.now() - msAgo;
        // Find the closest price point at or before targetTime
        for (let i = this.priceHistory.length - 1; i >= 0; i--) {
            const entry = this.priceHistory[i];
            if (entry.timestamp <= targetTime) {
                return side === 'UP' ? entry.upAsk : entry.downAsk;
            }
        }
        return null;
    }
    handleChainlinkPriceUpdate(price) {
        if (!this.market)
            return;
        // Only handle updates for our underlying (symbol format: ETH/USD)
        const expectedSymbol = `${this.market.underlying}/USD`;
        if (price.symbol !== expectedSymbol)
            return;
        if (this.config.debug) {
            this.log(`Chainlink price update: ${price.symbol} = $${price.price.toFixed(2)}`);
        }
        this.currentUnderlyingPrice = price.price;
        // Emit price update event
        if (this.currentRound) {
            const event = {
                underlying: this.market.underlying,
                value: price.price,
                priceToBeat: this.currentRound.priceToBeat,
                changePercent: this.currentRound.priceToBeat > 0
                    ? ((price.price - this.currentRound.priceToBeat) / this.currentRound.priceToBeat) * 100
                    : 0,
            };
            this.emit('priceUpdate', event);
        }
    }
    // ===== Private: Round Management =====
    async checkAndStartNewRound() {
        if (!this.market)
            return;
        // If no current round or current round is completed/expired, start new round
        if (!this.currentRound || this.currentRound.phase === 'completed' || this.currentRound.phase === 'expired') {
            // Check if market is still active
            if (new Date() >= this.market.endTime) {
                // Always log market end (not just in debug mode)
                if (!this.currentRound) {
                    console.log('[DipArb] Market has ended before round could start');
                }
                return;
            }
            // Get current prices
            const upPrice = this.upAsks[0]?.price ?? 0.5;
            const downPrice = this.downAsks[0]?.price ?? 0.5;
            // Use current underlying price as price to beat (or fallback to 0)
            const priceToBeat = this.currentUnderlyingPrice || 0;
            // Create new round
            const roundId = `${this.market.slug}-${Date.now()}`;
            this.currentRound = createDipArbRoundState(roundId, priceToBeat, upPrice, downPrice, this.market.durationMinutes);
            // Clear price history for new round - we only want to detect instant drops within this round
            this.priceHistory = [];
            // Reset signal state for new round
            this.leg1SignalEmitted = false;
            this.stats.roundsMonitored++;
            const event = {
                roundId,
                priceToBeat,
                upOpen: upPrice,
                downOpen: downPrice,
                startTime: this.currentRound.startTime,
                endTime: this.currentRound.endTime,
            };
            this.emit('newRound', event);
            this.log(`New round: ${roundId}, Price to Beat: ${priceToBeat.toFixed(2)}`);
        }
        // Check for round expiration - exit Leg1 if Leg2 times out
        if (this.currentRound && this.currentRound.phase === 'leg1_filled') {
            const elapsed = (Date.now() - (this.currentRound.leg1?.timestamp || this.currentRound.startTime)) / 1000;
            if (elapsed > this.config.leg2TimeoutSeconds) {
                // ✅ FIX: Exit Leg1 position to avoid unhedged exposure
                this.log(`⚠️ Leg2 timeout (${elapsed.toFixed(0)}s > ${this.config.leg2TimeoutSeconds}s), exiting Leg1 position...`);
                // Try to sell Leg1 position
                const exitResult = await this.emergencyExitLeg1();
                this.currentRound.phase = 'expired';
                this.stats.roundsExpired++;
                this.stats.roundsCompleted++;
                const result = {
                    roundId: this.currentRound.roundId,
                    status: 'expired',
                    leg1: this.currentRound.leg1,
                    merged: false,
                    exitResult, // Include exit result for tracking
                };
                this.emit('roundComplete', result);
                this.log(`Round expired: ${this.currentRound.roundId} | Exit: ${exitResult?.success ? 'SUCCESS' : 'FAILED'}`);
            }
        }
    }
    /**
     * Emergency exit Leg1 position when Leg2 times out
     * Sells the Leg1 tokens at market price to avoid unhedged exposure
     */
    async emergencyExitLeg1() {
        if (!this.tradingService || !this.market || !this.currentRound?.leg1) {
            this.log('Cannot exit Leg1: no trading service or position');
            return null;
        }
        const leg1 = this.currentRound.leg1;
        const startTime = Date.now();
        try {
            this.log(`Selling ${leg1.shares} ${leg1.side} tokens...`);
            // Get current price for the token
            const currentPrice = leg1.side === 'UP'
                ? (this.upAsks[0]?.price ?? 0.5)
                : (this.downAsks[0]?.price ?? 0.5);
            // Market sell the position
            const result = await this.tradingService.createMarketOrder({
                tokenId: leg1.tokenId,
                side: 'SELL',
                amount: leg1.shares * currentPrice, // Sell all shares
            });
            if (result.success) {
                const soldPrice = currentPrice; // Approximate
                const loss = (leg1.price - soldPrice) * leg1.shares;
                this.log(`✅ Leg1 exit successful: sold ${leg1.shares}x ${leg1.side} @ ~${soldPrice.toFixed(4)} | Loss: $${loss.toFixed(2)}`);
                // Update stats with the loss
                this.stats.totalProfit -= Math.abs(loss);
                return {
                    success: true,
                    leg: 'exit',
                    roundId: this.currentRound.roundId,
                    side: leg1.side,
                    price: soldPrice,
                    shares: leg1.shares,
                    orderId: result.orderId,
                    executionTimeMs: Date.now() - startTime,
                };
            }
            else {
                this.log(`❌ Leg1 exit failed: ${result.errorMsg}`);
                return {
                    success: false,
                    leg: 'exit',
                    roundId: this.currentRound.roundId,
                    error: result.errorMsg,
                    executionTimeMs: Date.now() - startTime,
                };
            }
        }
        catch (error) {
            this.log(`❌ Leg1 exit error: ${error instanceof Error ? error.message : String(error)}`);
            return {
                success: false,
                leg: 'exit',
                roundId: this.currentRound.roundId,
                error: error instanceof Error ? error.message : String(error),
                executionTimeMs: Date.now() - startTime,
            };
        }
    }
    // ===== Private: Signal Detection =====
    detectSignal() {
        if (!this.currentRound || !this.market)
            return null;
        // Check based on current phase
        if (this.currentRound.phase === 'waiting') {
            return this.detectLeg1Signal();
        }
        else if (this.currentRound.phase === 'leg1_filled') {
            return this.detectLeg2Signal();
        }
        return null;
    }
    detectLeg1Signal() {
        if (!this.currentRound || !this.market)
            return null;
        // Check if within trading window (轮次开始后的交易窗口)
        const elapsed = (Date.now() - this.currentRound.startTime) / 60000;
        if (elapsed > this.config.windowMinutes) {
            return null;
        }
        const upPrice = this.upAsks[0]?.price ?? 1;
        const downPrice = this.downAsks[0]?.price ?? 1;
        const { openPrices } = this.currentRound;
        // Skip if no valid prices
        if (upPrice >= 1 || downPrice >= 1 || openPrices.up <= 0 || openPrices.down <= 0) {
            return null;
        }
        // ========================================
        // Pattern 1: Instant Dip Detection (核心策略)
        // ========================================
        // 检测 slidingWindowMs (默认 3 秒) 内的瞬时暴跌
        // 这是策略的核心！我们捕捉的是"情绪性暴跌"，不是趋势
        const upPriceAgo = this.getPriceFromHistory('UP', this.config.slidingWindowMs);
        const downPriceAgo = this.getPriceFromHistory('DOWN', this.config.slidingWindowMs);
        // UP instant dip: 3秒内暴跌 >= dipThreshold
        if (upPriceAgo !== null && upPriceAgo > 0) {
            const upInstantDrop = (upPriceAgo - upPrice) / upPriceAgo;
            if (upInstantDrop >= this.config.dipThreshold) {
                if (this.config.debug) {
                    this.log(`⚡ Instant DIP detected! UP: ${upPriceAgo.toFixed(4)} → ${upPrice.toFixed(4)} = -${(upInstantDrop * 100).toFixed(1)}% in ${this.config.slidingWindowMs}ms`);
                }
                const signal = this.createLeg1Signal('UP', upPrice, downPrice, 'dip', upInstantDrop, upPriceAgo);
                if (signal && this.validateSignalProfitability(signal)) {
                    return signal;
                }
            }
        }
        // DOWN instant dip: 3秒内暴跌 >= dipThreshold
        if (downPriceAgo !== null && downPriceAgo > 0) {
            const downInstantDrop = (downPriceAgo - downPrice) / downPriceAgo;
            if (downInstantDrop >= this.config.dipThreshold) {
                if (this.config.debug) {
                    this.log(`⚡ Instant DIP detected! DOWN: ${downPriceAgo.toFixed(4)} → ${downPrice.toFixed(4)} = -${(downInstantDrop * 100).toFixed(1)}% in ${this.config.slidingWindowMs}ms`);
                }
                const signal = this.createLeg1Signal('DOWN', downPrice, upPrice, 'dip', downInstantDrop, downPriceAgo);
                if (signal && this.validateSignalProfitability(signal)) {
                    return signal;
                }
            }
        }
        // ========================================
        // Pattern 2: Surge Detection (if enabled)
        // ========================================
        // 暴涨检测：当 token 价格暴涨时，买入对手 token
        if (this.config.enableSurge && upPriceAgo !== null && downPriceAgo !== null) {
            // UP surged in sliding window, buy DOWN
            if (upPriceAgo > 0) {
                const upSurge = (upPrice - upPriceAgo) / upPriceAgo;
                if (upSurge >= this.config.surgeThreshold) {
                    if (this.config.debug) {
                        this.log(`⚡ Instant SURGE detected! UP: ${upPriceAgo.toFixed(4)} → ${upPrice.toFixed(4)} = +${(upSurge * 100).toFixed(1)}% in ${this.config.slidingWindowMs}ms`);
                    }
                    // 买入 DOWN，参考价格是 DOWN 的历史价格
                    const signal = this.createLeg1Signal('DOWN', downPrice, upPrice, 'surge', upSurge, downPriceAgo);
                    if (signal && this.validateSignalProfitability(signal)) {
                        return signal;
                    }
                }
            }
            // DOWN surged in sliding window, buy UP
            if (downPriceAgo > 0) {
                const downSurge = (downPrice - downPriceAgo) / downPriceAgo;
                if (downSurge >= this.config.surgeThreshold) {
                    if (this.config.debug) {
                        this.log(`⚡ Instant SURGE detected! DOWN: ${downPriceAgo.toFixed(4)} → ${downPrice.toFixed(4)} = +${(downSurge * 100).toFixed(1)}% in ${this.config.slidingWindowMs}ms`);
                    }
                    // 买入 UP，参考价格是 UP 的历史价格
                    const signal = this.createLeg1Signal('UP', upPrice, downPrice, 'surge', downSurge, upPriceAgo);
                    if (signal && this.validateSignalProfitability(signal)) {
                        return signal;
                    }
                }
            }
        }
        // ========================================
        // Pattern 3: Mispricing Detection
        // ========================================
        // 定价偏差：基于底层资产价格估计胜率，检测错误定价
        if (this.currentRound.priceToBeat > 0 && this.currentUnderlyingPrice > 0) {
            const estimatedWinRate = estimateUpWinRate(this.currentUnderlyingPrice, this.currentRound.priceToBeat);
            const upMispricing = detectMispricing(upPrice, estimatedWinRate);
            const downMispricing = detectMispricing(downPrice, 1 - estimatedWinRate);
            // UP is underpriced
            if (upMispricing >= this.config.dipThreshold) {
                const signal = this.createLeg1Signal('UP', upPrice, downPrice, 'mispricing', upMispricing);
                if (signal && this.validateSignalProfitability(signal)) {
                    return signal;
                }
            }
            // DOWN is underpriced
            if (downMispricing >= this.config.dipThreshold) {
                const signal = this.createLeg1Signal('DOWN', downPrice, upPrice, 'mispricing', downMispricing);
                if (signal && this.validateSignalProfitability(signal)) {
                    return signal;
                }
            }
        }
        return null;
    }
    createLeg1Signal(side, price, oppositeAsk, source, dropPercent, referencePrice // 用于 dip/surge: 滑动窗口前的价格
    ) {
        if (!this.currentRound || !this.market)
            return null;
        const targetPrice = price * (1 + this.config.maxSlippage);
        const estimatedTotalCost = targetPrice + oppositeAsk;
        const estimatedProfitRate = calculateDipArbProfitRate(estimatedTotalCost);
        // openPrice: 对于 dip/surge 信号，使用滑动窗口参考价格；否则使用轮次开盘价
        const openPrice = referencePrice ??
            (side === 'UP' ? this.currentRound.openPrices.up : this.currentRound.openPrices.down);
        const signal = {
            type: 'leg1',
            roundId: this.currentRound.roundId,
            dipSide: side,
            currentPrice: price,
            openPrice, // 参考价格（3秒前的价格或轮次开盘价）
            dropPercent,
            targetPrice,
            shares: this.config.shares,
            tokenId: side === 'UP' ? this.market.upTokenId : this.market.downTokenId,
            oppositeAsk,
            estimatedTotalCost,
            estimatedProfitRate,
            source,
        };
        // Add BTC info if available
        if (this.currentRound.priceToBeat > 0 && this.currentUnderlyingPrice > 0) {
            const btcChangePercent = ((this.currentUnderlyingPrice - this.currentRound.priceToBeat) / this.currentRound.priceToBeat) * 100;
            signal.btcInfo = {
                btcPrice: this.currentUnderlyingPrice,
                priceToBeat: this.currentRound.priceToBeat,
                btcChangePercent,
                estimatedWinRate: estimateUpWinRate(this.currentUnderlyingPrice, this.currentRound.priceToBeat),
            };
        }
        return signal;
    }
    detectLeg2Signal() {
        if (!this.currentRound || !this.market || !this.currentRound.leg1)
            return null;
        const leg1 = this.currentRound.leg1;
        const hedgeSide = leg1.side === 'UP' ? 'DOWN' : 'UP';
        const currentPrice = hedgeSide === 'UP' ? (this.upAsks[0]?.price ?? 1) : (this.downAsks[0]?.price ?? 1);
        if (currentPrice >= 1)
            return null;
        const targetPrice = currentPrice * (1 + this.config.maxSlippage);
        const totalCost = leg1.price + targetPrice;
        // Check if profitable - 只用 sumTarget 控制
        if (totalCost > this.config.sumTarget) {
            // 每 5 秒输出一次等待日志，避免刷屏
            if (this.config.debug && Date.now() % 5000 < 100) {
                const profitRate = calculateDipArbProfitRate(totalCost);
                this.log(`⏳ Waiting Leg2: ${hedgeSide} @ ${currentPrice.toFixed(4)}, cost ${totalCost.toFixed(4)} > ${this.config.sumTarget}, profit ${(profitRate * 100).toFixed(1)}%`);
            }
            return null;
        }
        const expectedProfitRate = calculateDipArbProfitRate(totalCost);
        if (this.config.debug) {
            this.log(`✅ Leg2 signal found! ${hedgeSide} @ ${currentPrice.toFixed(4)}, totalCost ${totalCost.toFixed(4)}, profit ${(expectedProfitRate * 100).toFixed(2)}%`);
        }
        // ✅ FIX: Use leg1.shares instead of config.shares to ensure balanced hedge
        // This is critical - Leg2 must buy exactly the same shares as Leg1 to create a perfect hedge
        return {
            type: 'leg2',
            roundId: this.currentRound.roundId,
            hedgeSide,
            leg1,
            currentPrice,
            targetPrice,
            totalCost,
            expectedProfitRate,
            shares: leg1.shares, // Must match Leg1 to ensure balanced hedge
            tokenId: hedgeSide === 'UP' ? this.market.upTokenId : this.market.downTokenId,
        };
    }
    validateSignalProfitability(signal) {
        // Leg1 验证：只检查跌幅是否足够大
        // 不在 Leg1 阶段检查 sumTarget，因为：
        // 1. Leg1 的目的是抄底，买入暴跌的一侧
        // 2. Leg2 会等待对侧价格下降后再买入
        // 3. sumTarget 应该在 Leg2 阶段检查
        // 只做基本验证：确保价格合理
        if (signal.currentPrice <= 0 || signal.currentPrice >= 1) {
            if (this.config.debug) {
                this.log(`❌ Signal rejected: invalid price ${signal.currentPrice.toFixed(4)}`);
            }
            return false;
        }
        // 确保跌幅达到阈值（这个已经在 detectLeg1Signal 中检查过，这里再确认一下）
        if (signal.dropPercent < this.config.dipThreshold) {
            if (this.config.debug) {
                this.log(`❌ Signal rejected: drop ${(signal.dropPercent * 100).toFixed(1)}% < threshold ${(this.config.dipThreshold * 100).toFixed(1)}%`);
            }
            return false;
        }
        if (this.config.debug) {
            this.log(`✅ Leg1 signal validated: ${signal.dipSide} @ ${signal.currentPrice.toFixed(4)}, drop ${(signal.dropPercent * 100).toFixed(1)}%`);
            this.log(`   (Leg2 will check sumTarget when opposite price drops)`);
        }
        return true;
    }
    // ===== Private: Signal Handling =====
    async handleSignal(signal) {
        // Check if we can execute before emitting signal
        // This prevents logging signals that won't be executed
        if (!this.config.autoExecute) {
            // Manual mode: always emit signal for user to decide
            this.stats.signalsDetected++;
            this.emit('signal', signal);
            if (this.config.debug) {
                if (isDipArbLeg1Signal(signal)) {
                    this.log(`Signal: Leg1 ${signal.dipSide} @ ${signal.currentPrice.toFixed(4)} (${signal.source})`);
                }
                else {
                    this.log(`Signal: Leg2 ${signal.hedgeSide} @ ${signal.currentPrice.toFixed(4)}`);
                }
            }
            return;
        }
        // Auto-execute mode: only emit and log if we will actually execute
        if (this.isExecuting) {
            // Skip - already executing another order
            if (this.config.debug) {
                this.log(`Signal skipped (executing): ${isDipArbLeg1Signal(signal) ? 'Leg1' : 'Leg2'}`);
            }
            return;
        }
        const now = Date.now();
        if (now - this.lastExecutionTime < this.config.executionCooldown) {
            // Skip - within cooldown period
            if (this.config.debug) {
                const remaining = this.config.executionCooldown - (now - this.lastExecutionTime);
                this.log(`Signal skipped (cooldown ${remaining}ms): ${isDipArbLeg1Signal(signal) ? 'Leg1' : 'Leg2'}`);
            }
            return;
        }
        // Will execute - now emit signal and log
        this.stats.signalsDetected++;
        this.emit('signal', signal);
        if (this.config.debug) {
            if (isDipArbLeg1Signal(signal)) {
                this.log(`Signal: Leg1 ${signal.dipSide} @ ${signal.currentPrice.toFixed(4)} (${signal.source})`);
            }
            else {
                this.log(`Signal: Leg2 ${signal.hedgeSide} @ ${signal.currentPrice.toFixed(4)}`);
            }
        }
        // Execute
        let result;
        if (isDipArbLeg1Signal(signal)) {
            result = await this.executeLeg1(signal);
        }
        else {
            result = await this.executeLeg2(signal);
        }
        this.emit('execution', result);
    }
    // ===== Public API: Auto-Rotate =====
    /**
     * Configure and enable auto-rotate
     *
     * Auto-rotate 会自动：
     * 1. 监控当前市场到期时间
     * 2. 在市场结束前预加载下一个市场
     * 3. 市场结束时自动结算（redeem 或 sell）
     * 4. 无缝切换到下一个 15m 市场
     *
     * @example
     * ```typescript
     * sdk.dipArb.enableAutoRotate({
     *   underlyings: ['BTC', 'ETH'],
     *   duration: '15m',
     *   autoSettle: true,
     *   settleStrategy: 'redeem',
     * });
     * ```
     */
    enableAutoRotate(config = {}) {
        this.autoRotateConfig = {
            ...this.autoRotateConfig,
            ...config,
            enabled: true,
        };
        this.log(`Auto-rotate enabled: ${JSON.stringify(this.autoRotateConfig)}`);
        this.startRotateCheck();
        // Start background redemption check if using redeem strategy
        if (this.autoRotateConfig.settleStrategy === 'redeem') {
            this.startRedeemCheck();
        }
    }
    /**
     * Disable auto-rotate
     */
    disableAutoRotate() {
        this.autoRotateConfig.enabled = false;
        this.stopRotateCheck();
        this.stopRedeemCheck();
        this.log('Auto-rotate disabled');
        // Warn if there are pending redemptions
        if (this.pendingRedemptions.length > 0) {
            this.log(`Warning: ${this.pendingRedemptions.length} pending redemptions will not be processed`);
        }
    }
    /**
     * Get auto-rotate configuration
     */
    getAutoRotateConfig() {
        return { ...this.autoRotateConfig };
    }
    /**
     * Manually settle current position
     *
     * 结算策略：
     * - 'redeem': 等待市场结算后 redeem（需要等待结算完成）
     * - 'sell': 直接卖出 token（更快但可能有滑点）
     */
    async settle(strategy = 'redeem') {
        const startTime = Date.now();
        if (!this.market || !this.currentRound) {
            return {
                success: false,
                strategy,
                error: 'No active market or round',
                executionTimeMs: Date.now() - startTime,
            };
        }
        try {
            if (strategy === 'redeem') {
                return await this.settleByRedeem();
            }
            else {
                return await this.settleBySell();
            }
        }
        catch (error) {
            return {
                success: false,
                strategy,
                error: error instanceof Error ? error.message : String(error),
                executionTimeMs: Date.now() - startTime,
            };
        }
    }
    /**
     * Manually rotate to next market
     */
    async rotateToNextMarket() {
        if (!this.autoRotateConfig.enabled) {
            this.log('Auto-rotate not enabled');
            return null;
        }
        // Find next market
        const nextMarket = await this.findNextMarket();
        if (!nextMarket) {
            this.log('No suitable next market found');
            return null;
        }
        // Stop current monitoring
        await this.stop();
        // Start new market
        await this.start(nextMarket);
        const event = {
            previousMarket: this.market?.conditionId,
            newMarket: nextMarket.conditionId,
            reason: 'manual',
            timestamp: Date.now(),
        };
        this.emit('rotate', event);
        return nextMarket;
    }
    // ===== Private: Auto-Rotate Implementation =====
    startRotateCheck() {
        if (this.rotateCheckInterval) {
            clearInterval(this.rotateCheckInterval);
        }
        // Check every 30 seconds
        this.rotateCheckInterval = setInterval(() => {
            this.checkRotation();
        }, 30000);
        // Also check immediately
        this.checkRotation();
    }
    stopRotateCheck() {
        if (this.rotateCheckInterval) {
            clearInterval(this.rotateCheckInterval);
            this.rotateCheckInterval = null;
        }
    }
    // ===== Private: Pending Redemption Processing =====
    startRedeemCheck() {
        if (this.redeemCheckInterval) {
            clearInterval(this.redeemCheckInterval);
        }
        const intervalMs = (this.autoRotateConfig.redeemRetryIntervalSeconds || 30) * 1000;
        // Check every 30 seconds (configurable)
        this.redeemCheckInterval = setInterval(() => {
            this.processPendingRedemptions();
        }, intervalMs);
        this.log(`Redeem check started (interval: ${intervalMs / 1000}s)`);
    }
    stopRedeemCheck() {
        if (this.redeemCheckInterval) {
            clearInterval(this.redeemCheckInterval);
            this.redeemCheckInterval = null;
        }
    }
    /**
     * Add a position to pending redemption queue
     */
    addPendingRedemption(market, round) {
        const pending = {
            market,
            round,
            marketEndTime: market.endTime.getTime(),
            addedAt: Date.now(),
            retryCount: 0,
        };
        this.pendingRedemptions.push(pending);
        this.log(`Added pending redemption: ${market.slug} (queue size: ${this.pendingRedemptions.length})`);
    }
    /**
     * Process all pending redemptions
     * Called periodically by redeemCheckInterval
     */
    async processPendingRedemptions() {
        if (this.pendingRedemptions.length === 0) {
            return;
        }
        const now = Date.now();
        const waitMs = (this.autoRotateConfig.redeemWaitMinutes || 5) * 60 * 1000;
        for (let i = this.pendingRedemptions.length - 1; i >= 0; i--) {
            const pending = this.pendingRedemptions[i];
            const timeSinceEnd = now - pending.marketEndTime;
            // Skip if not enough time has passed since market end
            if (timeSinceEnd < waitMs) {
                const waitLeft = Math.round((waitMs - timeSinceEnd) / 1000);
                if (this.config.debug) {
                    this.log(`Pending redemption ${pending.market.slug}: waiting ${waitLeft}s more for resolution`);
                }
                continue;
            }
            // Try to redeem
            pending.retryCount++;
            pending.lastRetryAt = now;
            try {
                if (!this.ctf) {
                    this.log(`Cannot redeem ${pending.market.slug}: CTF client not available`);
                    continue;
                }
                // Check if market is resolved
                const resolution = await this.ctf.getMarketResolution(pending.market.conditionId);
                if (!resolution.isResolved) {
                    this.log(`Pending redemption ${pending.market.slug}: market not yet resolved (retry ${pending.retryCount})`);
                    // Give up after too many retries (10 minutes of trying)
                    if (pending.retryCount > 20) {
                        this.log(`Giving up on redemption ${pending.market.slug}: too many retries`);
                        this.pendingRedemptions.splice(i, 1);
                        this.emit('settled', {
                            success: false,
                            strategy: 'redeem',
                            market: pending.market,
                            error: 'Market not resolved after max retries',
                            executionTimeMs: 0,
                        });
                    }
                    continue;
                }
                // Market is resolved, try to redeem using Polymarket token IDs
                this.log(`Redeeming ${pending.market.slug}...`);
                const tokenIds = {
                    yesTokenId: pending.market.upTokenId,
                    noTokenId: pending.market.downTokenId,
                };
                const result = await this.ctf.redeemByTokenIds(pending.market.conditionId, tokenIds);
                // Remove from queue
                this.pendingRedemptions.splice(i, 1);
                const settleResult = {
                    success: result.success,
                    strategy: 'redeem',
                    market: pending.market,
                    txHash: result.txHash,
                    amountReceived: result.usdcReceived ? parseFloat(result.usdcReceived) : undefined,
                    executionTimeMs: 0,
                };
                this.emit('settled', settleResult);
                this.log(`Redemption successful: ${pending.market.slug} | Amount: $${settleResult.amountReceived?.toFixed(2) || 'N/A'}`);
                // Update stats
                if (settleResult.amountReceived) {
                    this.stats.totalProfit += settleResult.amountReceived;
                }
            }
            catch (error) {
                this.log(`Redemption error for ${pending.market.slug}: ${error instanceof Error ? error.message : String(error)}`);
                // Give up after too many retries
                if (pending.retryCount > 20) {
                    this.log(`Giving up on redemption ${pending.market.slug}: error after max retries`);
                    this.pendingRedemptions.splice(i, 1);
                    this.emit('settled', {
                        success: false,
                        strategy: 'redeem',
                        market: pending.market,
                        error: error instanceof Error ? error.message : String(error),
                        executionTimeMs: 0,
                    });
                }
            }
        }
    }
    /**
     * Get pending redemptions (for debugging/monitoring)
     */
    getPendingRedemptions() {
        return [...this.pendingRedemptions];
    }
    async checkRotation() {
        if (!this.autoRotateConfig.enabled || !this.market) {
            if (this.config.debug) {
                this.log(`checkRotation: skipped (enabled=${this.autoRotateConfig.enabled}, market=${!!this.market})`);
            }
            return;
        }
        const now = Date.now();
        const endTime = this.market.endTime.getTime();
        const timeUntilEnd = endTime - now;
        const preloadMs = (this.autoRotateConfig.preloadMinutes || 2) * 60 * 1000;
        if (this.config.debug) {
            const timeLeftSec = Math.round(timeUntilEnd / 1000);
            this.log(`checkRotation: timeUntilEnd=${timeLeftSec}s, preloadMs=${preloadMs / 1000}s, nextMarket=${this.nextMarket?.slug || 'none'}`);
        }
        // Preload next market when close to end
        if (timeUntilEnd <= preloadMs && !this.nextMarket) {
            this.log('Preloading next market...');
            this.nextMarket = await this.findNextMarket();
            if (this.nextMarket) {
                this.log(`Next market ready: ${this.nextMarket.slug}`);
            }
            else {
                this.log('No next market found during preload');
            }
        }
        // Market ended - settle and rotate
        if (timeUntilEnd <= 0) {
            this.log(`Market ended ${Math.round(-timeUntilEnd / 1000)}s ago, initiating rotation...`);
            // Settle if configured and has position
            if (this.autoRotateConfig.autoSettle && this.currentRound?.leg1) {
                const strategy = this.autoRotateConfig.settleStrategy || 'redeem';
                if (strategy === 'redeem') {
                    // For redeem strategy, add to pending queue (will be processed after 5 min wait)
                    this.addPendingRedemption(this.market, this.currentRound);
                    this.log(`Position added to pending redemption queue (will redeem after ${this.autoRotateConfig.redeemWaitMinutes || 5}min)`);
                }
                else {
                    // For sell strategy, execute immediately
                    const settleResult = await this.settle('sell');
                    this.emit('settled', settleResult);
                }
            }
            // Rotate to next market
            if (this.nextMarket) {
                const previousMarket = this.market;
                const newMarket = this.nextMarket;
                this.nextMarket = null;
                // Stop current market (this clears the rotate check interval)
                await this.stop();
                // Start new market
                await this.start(newMarket);
                // Restart the rotate check interval for the new market
                this.startRotateCheck();
                const event = {
                    previousMarket: previousMarket.conditionId,
                    newMarket: newMarket.conditionId,
                    reason: 'marketEnded',
                    timestamp: Date.now(),
                };
                this.emit('rotate', event);
            }
            else {
                // Try to find a market
                this.log('No preloaded market, searching...');
                const newMarket = await this.findNextMarket();
                if (newMarket) {
                    const previousMarket = this.market;
                    // Stop current market (this clears the rotate check interval)
                    await this.stop();
                    // Start new market
                    await this.start(newMarket);
                    // Restart the rotate check interval for the new market
                    this.startRotateCheck();
                    const event = {
                        previousMarket: previousMarket.conditionId,
                        newMarket: newMarket.conditionId,
                        reason: 'marketEnded',
                        timestamp: Date.now(),
                    };
                    this.emit('rotate', event);
                }
                else {
                    this.log('No next market available, stopping...');
                    await this.stop();
                }
            }
        }
    }
    async findNextMarket() {
        const markets = await this.scanUpcomingMarkets({
            coin: this.autoRotateConfig.underlyings.length === 1
                ? this.autoRotateConfig.underlyings[0]
                : 'all',
            duration: this.autoRotateConfig.duration,
            minMinutesUntilEnd: 5,
            maxMinutesUntilEnd: 30,
            limit: 10,
        });
        // Filter to configured underlyings
        const filtered = markets.filter(m => this.autoRotateConfig.underlyings.includes(m.underlying));
        // Exclude current market
        const available = filtered.filter(m => m.conditionId !== this.market?.conditionId);
        // Return the soonest one
        return available.length > 0 ? available[0] : null;
    }
    async settleByRedeem() {
        const startTime = Date.now();
        if (!this.ctf || !this.market) {
            return {
                success: false,
                strategy: 'redeem',
                error: 'CTF client or market not available',
                executionTimeMs: Date.now() - startTime,
            };
        }
        try {
            // Check market resolution first
            const resolution = await this.ctf.getMarketResolution(this.market.conditionId);
            if (!resolution.isResolved) {
                return {
                    success: false,
                    strategy: 'redeem',
                    error: 'Market not yet resolved',
                    executionTimeMs: Date.now() - startTime,
                };
            }
            // Redeem winning tokens using Polymarket token IDs
            const tokenIds = {
                yesTokenId: this.market.upTokenId,
                noTokenId: this.market.downTokenId,
            };
            const result = await this.ctf.redeemByTokenIds(this.market.conditionId, tokenIds);
            return {
                success: result.success,
                strategy: 'redeem',
                txHash: result.txHash,
                amountReceived: result.usdcReceived ? parseFloat(result.usdcReceived) : undefined,
                executionTimeMs: Date.now() - startTime,
            };
        }
        catch (error) {
            return {
                success: false,
                strategy: 'redeem',
                error: error instanceof Error ? error.message : String(error),
                executionTimeMs: Date.now() - startTime,
            };
        }
    }
    async settleBySell() {
        const startTime = Date.now();
        if (!this.tradingService || !this.market || !this.currentRound) {
            return {
                success: false,
                strategy: 'sell',
                error: 'Trading service or market not available',
                executionTimeMs: Date.now() - startTime,
            };
        }
        try {
            let totalReceived = 0;
            // Sell leg1 position if exists
            if (this.currentRound.leg1) {
                const leg1Shares = this.currentRound.leg1.shares;
                const result = await this.tradingService.createMarketOrder({
                    tokenId: this.currentRound.leg1.tokenId,
                    side: 'SELL',
                    amount: leg1Shares,
                });
                if (result.success) {
                    totalReceived += leg1Shares * (this.currentRound.leg1.side === 'UP'
                        ? (this.upAsks[0]?.price ?? 0.5)
                        : (this.downAsks[0]?.price ?? 0.5));
                }
            }
            // Sell leg2 position if exists
            if (this.currentRound.leg2) {
                const leg2Shares = this.currentRound.leg2.shares;
                const result = await this.tradingService.createMarketOrder({
                    tokenId: this.currentRound.leg2.tokenId,
                    side: 'SELL',
                    amount: leg2Shares,
                });
                if (result.success) {
                    totalReceived += leg2Shares * (this.currentRound.leg2.side === 'UP'
                        ? (this.upAsks[0]?.price ?? 0.5)
                        : (this.downAsks[0]?.price ?? 0.5));
                }
            }
            return {
                success: true,
                strategy: 'sell',
                amountReceived: totalReceived,
                executionTimeMs: Date.now() - startTime,
            };
        }
        catch (error) {
            return {
                success: false,
                strategy: 'sell',
                error: error instanceof Error ? error.message : String(error),
                executionTimeMs: Date.now() - startTime,
            };
        }
    }
    // ===== Private: Helpers =====
    log(message) {
        const shouldLog = this.config.debug || message.startsWith('Starting') || message.startsWith('Stopped');
        if (!shouldLog)
            return;
        const formatted = `[DipArb] ${message}`;
        // Use custom log handler if provided
        if (this.config.logHandler) {
            this.config.logHandler(formatted);
        }
        else {
            console.log(formatted);
        }
    }
}
// Re-export types
export * from './dip-arb-types.js';
//# sourceMappingURL=dip-arb-service.js.map