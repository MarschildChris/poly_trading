/**
 * SmartMoneyService
 *
 * 聪明钱监控和自动跟单服务
 *
 * 核心功能：
 * 1. 监听指定地址的交易 - subscribeSmartMoneyTrades()
 * 2. 自动跟单 - startAutoCopyTrading()
 * 3. 聪明钱信息获取 - getSmartMoneyList(), getSmartMoneyInfo()
 *
 * ============================================================================
 * 设计决策
 * ============================================================================
 *
 * ## 监控方式
 * 使用 Activity WebSocket，延迟 < 100ms，实测验证有效。
 *
 * ## 下单方式
 * | 方式 | 使用场景 | 特点 |
 * |------|---------|------|
 * | FOK | 小额跟单 | 全部成交或取消 |
 * | FAK | 大额跟单 | 部分成交也接受 |
 *
 * ## 重要限制
 * ⚠️ Activity WebSocket 不会广播用户自己的交易！
 * 验证跟单结果请使用 TradingService.getTrades()
 */
// ============================================================================
// SmartMoneyService
// ============================================================================
export class SmartMoneyService {
    walletService;
    realtimeService;
    tradingService;
    config;
    smartMoneyCache = new Map();
    smartMoneySet = new Set();
    cacheTimestamp = 0;
    activeSubscription = null;
    tradeHandlers = new Set();
    constructor(walletService, realtimeService, tradingService, config = {}) {
        this.walletService = walletService;
        this.realtimeService = realtimeService;
        this.tradingService = tradingService;
        this.config = {
            minPnl: config.minPnl ?? 1000,
            cacheTtl: config.cacheTtl ?? 300000,
        };
    }
    // ============================================================================
    // Smart Money Info
    // ============================================================================
    /**
     * Get list of Smart Money wallets from leaderboard
     */
    async getSmartMoneyList(limit = 100) {
        if (this.isCacheValid()) {
            return Array.from(this.smartMoneyCache.values());
        }
        const leaderboardPage = await this.walletService.getLeaderboard(0, limit);
        const entries = leaderboardPage.entries;
        const smartMoneyList = [];
        for (let i = 0; i < entries.length; i++) {
            const trader = entries[i];
            if (trader.pnl < this.config.minPnl)
                continue;
            const wallet = {
                address: trader.address.toLowerCase(),
                name: trader.userName,
                pnl: trader.pnl,
                volume: trader.volume,
                score: Math.min(100, Math.round((trader.pnl / 100000) * 50 + (trader.volume / 1000000) * 50)),
                rank: trader.rank ?? i + 1,
            };
            smartMoneyList.push(wallet);
            this.smartMoneyCache.set(wallet.address, wallet);
            this.smartMoneySet.add(wallet.address);
        }
        this.cacheTimestamp = Date.now();
        return smartMoneyList;
    }
    /**
     * Check if an address is Smart Money
     */
    async isSmartMoney(address) {
        const normalized = address.toLowerCase();
        if (this.isCacheValid()) {
            return this.smartMoneySet.has(normalized);
        }
        await this.getSmartMoneyList();
        return this.smartMoneySet.has(normalized);
    }
    /**
     * Get Smart Money info for an address
     */
    async getSmartMoneyInfo(address) {
        const normalized = address.toLowerCase();
        if (this.isCacheValid() && this.smartMoneyCache.has(normalized)) {
            return this.smartMoneyCache.get(normalized);
        }
        await this.getSmartMoneyList();
        return this.smartMoneyCache.get(normalized) || null;
    }
    // ============================================================================
    // Trade Subscription - 监听交易
    // ============================================================================
    /**
     * Subscribe to trades from specific addresses
     *
     * @example
     * ```typescript
     * const sub = smartMoneyService.subscribeSmartMoneyTrades(
     *   (trade) => {
     *     console.log(`${trade.traderName} ${trade.side} ${trade.size} @ ${trade.price}`);
     *   },
     *   { filterAddresses: ['0x1234...', '0x5678...'] }
     * );
     *
     * // Stop listening
     * sub.unsubscribe();
     * ```
     */
    subscribeSmartMoneyTrades(onTrade, options = {}) {
        this.tradeHandlers.add(onTrade);
        // Ensure cache is populated
        this.getSmartMoneyList().catch(() => { });
        // Start subscription if not active
        if (!this.activeSubscription) {
            this.activeSubscription = this.realtimeService.subscribeAllActivity({
                onTrade: (activityTrade) => {
                    this.handleActivityTrade(activityTrade, options);
                },
                onError: (error) => {
                    console.error('[SmartMoneyService] Subscription error:', error);
                },
            });
        }
        return {
            id: `smart_money_${Date.now()}`,
            unsubscribe: () => {
                this.tradeHandlers.delete(onTrade);
                if (this.tradeHandlers.size === 0 && this.activeSubscription) {
                    this.activeSubscription.unsubscribe();
                    this.activeSubscription = null;
                }
            },
        };
    }
    async handleActivityTrade(trade, options) {
        const rawAddress = trade.trader?.address;
        if (!rawAddress)
            return;
        const traderAddress = rawAddress.toLowerCase();
        // Address filter
        if (options.filterAddresses && options.filterAddresses.length > 0) {
            const normalized = options.filterAddresses.map(a => a.toLowerCase());
            if (!normalized.includes(traderAddress))
                return;
        }
        // Size filter
        if (options.minSize && trade.size < options.minSize)
            return;
        // Smart Money filter
        const isSmartMoney = this.smartMoneySet.has(traderAddress);
        if (options.smartMoneyOnly && !isSmartMoney)
            return;
        const smartMoneyTrade = {
            traderAddress,
            traderName: trade.trader?.name,
            conditionId: trade.conditionId,
            marketSlug: trade.marketSlug,
            side: trade.side,
            size: trade.size,
            price: trade.price,
            tokenId: trade.asset,
            outcome: trade.outcome,
            txHash: trade.transactionHash,
            timestamp: trade.timestamp,
            isSmartMoney,
            smartMoneyInfo: this.smartMoneyCache.get(traderAddress),
        };
        for (const handler of this.tradeHandlers) {
            try {
                handler(smartMoneyTrade);
            }
            catch (error) {
                console.error('[SmartMoneyService] Handler error:', error);
            }
        }
    }
    // ============================================================================
    // Auto Copy Trading - 自动跟单
    // ============================================================================
    /**
     * Start auto copy trading - 自动跟单
     *
     * @example
     * ```typescript
     * const sub = await smartMoneyService.startAutoCopyTrading({
     *   targetAddresses: ['0x1234...'],
     *   // 或者跟踪排行榜前N名
     *   topN: 10,
     *
     *   sizeScale: 0.1,        // 10%
     *   maxSizePerTrade: 50,   // $50
     *   maxSlippage: 0.03,     // 3%
     *   orderType: 'FOK',
     *
     *   dryRun: true,          // 测试模式
     *
     *   onTrade: (trade, result) => console.log(result),
     * });
     *
     * // 停止
     * sub.stop();
     * ```
     */
    async startAutoCopyTrading(options) {
        const startTime = Date.now();
        // Build target list
        let targetAddresses = [];
        if (options.targetAddresses?.length) {
            targetAddresses = options.targetAddresses.map(a => a.toLowerCase());
        }
        if (options.topN && options.topN > 0) {
            const smartMoneyList = await this.getSmartMoneyList(options.topN);
            const topAddresses = smartMoneyList.map(w => w.address);
            targetAddresses = [...new Set([...targetAddresses, ...topAddresses])];
        }
        if (targetAddresses.length === 0) {
            throw new Error('No target addresses. Use targetAddresses or topN.');
        }
        // Stats
        const stats = {
            startTime,
            tradesDetected: 0,
            tradesExecuted: 0,
            tradesSkipped: 0,
            tradesFailed: 0,
            totalUsdcSpent: 0,
        };
        // Config
        const sizeScale = options.sizeScale ?? 0.1;
        const maxSizePerTrade = options.maxSizePerTrade ?? 50;
        const maxSlippage = options.maxSlippage ?? 0.03;
        const orderType = options.orderType ?? 'FOK';
        const minTradeSize = options.minTradeSize ?? 10;
        const sideFilter = options.sideFilter;
        const delay = options.delay ?? 0;
        const dryRun = options.dryRun ?? false;
        // Subscribe
        const subscription = this.subscribeSmartMoneyTrades(async (trade) => {
            stats.tradesDetected++;
            try {
                // Check target
                if (!targetAddresses.includes(trade.traderAddress.toLowerCase())) {
                    return;
                }
                // Filters
                const tradeValue = trade.size * trade.price;
                if (tradeValue < minTradeSize) {
                    stats.tradesSkipped++;
                    return;
                }
                if (sideFilter && trade.side !== sideFilter) {
                    stats.tradesSkipped++;
                    return;
                }
                // Calculate size
                let copySize = trade.size * sizeScale;
                let copyValue = copySize * trade.price;
                // Enforce max size
                if (copyValue > maxSizePerTrade) {
                    copySize = maxSizePerTrade / trade.price;
                    copyValue = maxSizePerTrade;
                }
                // Polymarket minimum order is $1
                const MIN_ORDER_SIZE = 1;
                if (copyValue < MIN_ORDER_SIZE) {
                    stats.tradesSkipped++;
                    return;
                }
                // Delay
                if (delay > 0) {
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
                // Token
                const tokenId = trade.tokenId;
                if (!tokenId) {
                    stats.tradesSkipped++;
                    return;
                }
                // Price with slippage
                const slippagePrice = trade.side === 'BUY'
                    ? trade.price * (1 + maxSlippage)
                    : trade.price * (1 - maxSlippage);
                const usdcAmount = copyValue; // Already calculated above
                // Execute
                let result;
                if (dryRun) {
                    result = { success: true, orderId: `dry_run_${Date.now()}` };
                    console.log('[DRY RUN]', {
                        trader: trade.traderAddress.slice(0, 10),
                        side: trade.side,
                        market: trade.marketSlug,
                        copy: { size: copySize.toFixed(2), usdc: usdcAmount.toFixed(2) },
                    });
                }
                else {
                    result = await this.tradingService.createMarketOrder({
                        tokenId,
                        side: trade.side,
                        amount: usdcAmount,
                        price: slippagePrice,
                        orderType,
                    });
                }
                if (result.success) {
                    stats.tradesExecuted++;
                    stats.totalUsdcSpent += usdcAmount;
                }
                else {
                    stats.tradesFailed++;
                }
                options.onTrade?.(trade, result);
            }
            catch (error) {
                stats.tradesFailed++;
                options.onError?.(error instanceof Error ? error : new Error(String(error)));
            }
        }, { filterAddresses: targetAddresses, minSize: minTradeSize });
        return {
            id: subscription.id,
            targetAddresses,
            startTime,
            isActive: true,
            stats,
            stop: () => subscription.unsubscribe(),
            getStats: () => ({ ...stats }),
        };
    }
    // ============================================================================
    // Leaderboard - 排行榜
    // ============================================================================
    /**
     * Get leaderboard by time period
     *
     * @example
     * ```typescript
     * // Get weekly top 100 by PnL
     * const leaderboard = await sdk.smartMoney.getLeaderboard({
     *   period: 'week',
     *   limit: 100,
     *   sortBy: 'pnl'
     * });
     * ```
     */
    async getLeaderboard(options = {}) {
        const period = options.period ?? 'week';
        const limit = Math.min(options.limit ?? 50, 500);
        const sortBy = options.sortBy ?? 'pnl';
        const offset = Math.min(options.offset ?? 0, 10000);
        const entries = await this.walletService.getLeaderboardByPeriod(period, limit, sortBy, 'OVERALL', offset);
        return entries.map(e => ({
            address: e.address,
            rank: e.rank,
            pnl: e.pnl,
            volume: e.volume,
            tradeCount: e.tradeCount,
            userName: e.userName,
            profileImage: e.profileImage,
        }));
    }
    // ============================================================================
    // Wallet Report - 钱包报告
    // ============================================================================
    /**
     * Generate comprehensive wallet report
     *
     * @example
     * ```typescript
     * const report = await sdk.smartMoney.getWalletReport('0x...');
     * console.log(report.overview.totalPnL);
     * console.log(report.rankings.weekly?.rank);
     * ```
     */
    async getWalletReport(address) {
        // Fetch all data in parallel
        const [profile, positions, activitySummary, dailyPnl, weeklyPnl, monthlyPnl, allTimePnl,] = await Promise.all([
            this.walletService.getWalletProfile(address),
            this.walletService.getWalletPositions(address),
            this.walletService.getWalletActivity(address, 100),
            this.walletService.getUserPeriodPnl(address, 'day').catch(() => null),
            this.walletService.getUserPeriodPnl(address, 'week').catch(() => null),
            this.walletService.getUserPeriodPnl(address, 'month').catch(() => null),
            this.walletService.getUserPeriodPnl(address, 'all').catch(() => null),
        ]);
        // Calculate performance metrics
        const winningPositions = positions.filter(p => (p.cashPnl ?? 0) > 0);
        const losingPositions = positions.filter(p => (p.cashPnl ?? 0) < 0);
        // Use initialValue (cost basis) instead of currentValue (which is 0 for settled markets)
        const avgPositionSize = positions.length > 0
            ? positions.reduce((sum, p) => sum + (p.initialValue ?? (p.size * p.avgPrice)), 0) / positions.length
            : 0;
        const avgWinAmount = winningPositions.length > 0
            ? winningPositions.reduce((sum, p) => sum + (p.cashPnl ?? 0), 0) / winningPositions.length
            : 0;
        const avgLossAmount = losingPositions.length > 0
            ? Math.abs(losingPositions.reduce((sum, p) => sum + (p.cashPnl ?? 0), 0) / losingPositions.length)
            : 0;
        const uniqueMarkets = new Set(positions.map(p => p.conditionId)).size;
        // Category analysis
        const categoryStats = this.analyzeCategories(positions);
        // Recent trades
        const trades = activitySummary.activities.filter(a => a.type === 'TRADE');
        const recentTrades = trades.slice(0, 10);
        // Build rankings
        const toRanking = (entry) => {
            if (!entry)
                return null;
            return { rank: entry.rank, pnl: entry.pnl, volume: entry.volume };
        };
        return {
            address,
            generatedAt: new Date(),
            overview: {
                totalPnL: profile.totalPnL,
                realizedPnL: profile.realizedPnL,
                unrealizedPnL: profile.unrealizedPnL,
                positionCount: positions.length,
                tradeCount: profile.tradeCount,
                smartScore: profile.smartScore,
                lastActiveAt: profile.lastActiveAt,
            },
            rankings: {
                daily: toRanking(dailyPnl),
                weekly: toRanking(weeklyPnl),
                monthly: toRanking(monthlyPnl),
                allTime: toRanking(allTimePnl),
            },
            performance: {
                winRate: positions.length > 0 ? (winningPositions.length / positions.length) * 100 : 0,
                winCount: winningPositions.length,
                lossCount: losingPositions.length,
                avgPositionSize,
                avgWinAmount,
                avgLossAmount,
                uniqueMarkets,
            },
            categoryBreakdown: categoryStats,
            topPositions: positions
                .sort((a, b) => Math.abs(b.cashPnl ?? 0) - Math.abs(a.cashPnl ?? 0))
                .slice(0, 10)
                .map(p => ({
                market: p.title,
                slug: p.slug,
                outcome: p.outcome,
                size: p.size,
                avgPrice: p.avgPrice,
                currentPrice: p.curPrice,
                pnl: p.cashPnl ?? 0,
                percentPnl: p.percentPnl,
            })),
            recentTrades: recentTrades.map(t => ({
                timestamp: t.timestamp,
                side: t.side,
                size: t.size,
                price: t.price,
                usdcSize: t.usdcSize,
                // Include market info for display
                title: t.title,
                slug: t.slug,
                outcome: t.outcome,
                conditionId: t.conditionId,
            })),
            activitySummary: {
                totalBuys: activitySummary.summary.totalBuys,
                totalSells: activitySummary.summary.totalSells,
                buyVolume: activitySummary.summary.buyVolume,
                sellVolume: activitySummary.summary.sellVolume,
                activeMarketsCount: activitySummary.summary.activeMarkets.length,
            },
        };
    }
    /**
     * Analyze position categories based on title keywords
     */
    analyzeCategories(positions) {
        const categoryStats = {};
        for (const pos of positions) {
            const title = (pos.title || '').toLowerCase();
            let category = 'other';
            if (title.includes('trump') || title.includes('biden') || title.includes('election') || title.includes('president') || title.includes('congress')) {
                category = 'politics';
            }
            else if (title.includes('bitcoin') || title.includes('btc') || title.includes('eth') || title.includes('crypto') || title.includes('solana')) {
                category = 'crypto';
            }
            else if (title.includes('nba') || title.includes('nfl') || title.includes('soccer') || title.includes('football') || title.includes('ufc') || title.includes('mlb')) {
                category = 'sports';
            }
            else if (title.includes('fed') || title.includes('inflation') || title.includes('gdp') || title.includes('interest rate') || title.includes('unemployment')) {
                category = 'economy';
            }
            else if (title.includes('ai') || title.includes('openai') || title.includes('google') || title.includes('apple') || title.includes('tesla')) {
                category = 'tech';
            }
            if (!categoryStats[category]) {
                categoryStats[category] = { count: 0, totalPnl: 0 };
            }
            categoryStats[category].count++;
            categoryStats[category].totalPnl += (pos.cashPnl ?? 0);
        }
        return Object.entries(categoryStats)
            .map(([category, stats]) => ({
            category,
            positionCount: stats.count,
            totalPnl: stats.totalPnl,
        }))
            .sort((a, b) => b.positionCount - a.positionCount);
    }
    // ============================================================================
    // Wallet Comparison - 钱包对比
    // ============================================================================
    /**
     * Compare multiple wallets
     *
     * @example
     * ```typescript
     * const comparison = await sdk.smartMoney.compareWallets(
     *   ['0x111...', '0x222...', '0x333...'],
     *   { period: 'week' }
     * );
     * ```
     */
    async compareWallets(addresses, options = {}) {
        const period = options.period ?? 'week';
        // Fetch data for all wallets in parallel
        const results = await Promise.all(addresses.map(async (address) => {
            const [periodPnl, positions] = await Promise.all([
                this.walletService.getUserPeriodPnl(address, period).catch(() => null),
                this.walletService.getWalletPositions(address).catch(() => []),
            ]);
            const winningPositions = positions.filter(p => (p.cashPnl ?? 0) > 0);
            const winRate = positions.length > 0
                ? (winningPositions.length / positions.length) * 100
                : 0;
            return {
                address,
                userName: periodPnl?.userName,
                rank: periodPnl?.rank ?? null,
                pnl: periodPnl?.pnl ?? 0,
                volume: periodPnl?.volume ?? 0,
                positionCount: positions.length,
                winRate,
            };
        }));
        // Sort by PnL descending
        results.sort((a, b) => b.pnl - a.pnl);
        return {
            period,
            generatedAt: new Date(),
            wallets: results,
        };
    }
    // ============================================================================
    // Utilities
    // ============================================================================
    isCacheValid() {
        return Date.now() - this.cacheTimestamp < this.config.cacheTtl && this.smartMoneyCache.size > 0;
    }
    disconnect() {
        if (this.activeSubscription) {
            this.activeSubscription.unsubscribe();
            this.activeSubscription = null;
        }
        this.tradeHandlers.clear();
        this.smartMoneyCache.clear();
        this.smartMoneySet.clear();
    }
}
//# sourceMappingURL=smart-money-service.js.map