/**
 * Realtime Service (Legacy Wrapper)
 *
 * This is a backward-compatible wrapper around RealtimeServiceV2.
 *
 * @deprecated Use RealtimeServiceV2 directly for full functionality.
 */
import { RealtimeServiceV2 } from './realtime-service-v2.js';
/**
 * @deprecated Use RealtimeServiceV2 instead for full topic support.
 */
export class RealtimeService {
    v2Service;
    subscriptions = new Map();
    subscriptionIdCounter = 0;
    priceCache = new Map();
    bookCache = new Map();
    constructor() {
        this.v2Service = new RealtimeServiceV2({ debug: false });
        this.v2Service.connect();
    }
    // ===== Market Subscriptions =====
    /**
     * Subscribe to market price updates
     * @param assetIds - Token IDs to subscribe to
     * @param handlers - Event handlers
     * @returns Subscription object with unsubscribe method
     */
    async subscribeMarkets(assetIds, handlers) {
        const subscriptionId = `sub_${++this.subscriptionIdCounter}`;
        const v2Sub = this.v2Service.subscribeMarkets(assetIds, {
            onOrderbook: (book) => {
                // Convert to BookUpdate
                const bookUpdate = {
                    assetId: book.assetId,
                    bids: book.bids,
                    asks: book.asks,
                    timestamp: book.timestamp,
                };
                this.bookCache.set(book.assetId, bookUpdate);
                handlers.onBookUpdate?.(bookUpdate);
                // Calculate derived price (Polymarket display logic)
                const priceUpdate = this.calculateDerivedPrice(book);
                if (priceUpdate) {
                    this.priceCache.set(book.assetId, priceUpdate);
                    handlers.onPriceUpdate?.(priceUpdate);
                }
            },
            onLastTrade: (trade) => {
                handlers.onLastTrade?.({
                    assetId: trade.assetId,
                    price: trade.price,
                    side: trade.side,
                    size: trade.size,
                    timestamp: trade.timestamp,
                });
            },
            onError: handlers.onError,
        });
        // Create subscription object
        const subscription = {
            id: subscriptionId,
            assetIds,
            unsubscribe: async () => {
                v2Sub.unsubscribe();
                this.subscriptions.delete(subscriptionId);
                // Clear caches for these assets
                assetIds.forEach(id => {
                    this.priceCache.delete(id);
                    this.bookCache.delete(id);
                });
            },
        };
        this.subscriptions.set(subscriptionId, { sub: v2Sub, assetIds });
        return subscription;
    }
    /**
     * Subscribe to a single market (both YES and NO tokens)
     */
    async subscribeMarket(yesTokenId, noTokenId, handlers) {
        let lastYesUpdate;
        let lastNoUpdate;
        const checkPairUpdate = () => {
            if (lastYesUpdate && lastNoUpdate && handlers.onPairUpdate) {
                handlers.onPairUpdate({
                    yes: lastYesUpdate,
                    no: lastNoUpdate,
                    spread: lastYesUpdate.price + lastNoUpdate.price,
                });
            }
        };
        return this.subscribeMarkets([yesTokenId, noTokenId], {
            onPriceUpdate: (update) => {
                if (update.assetId === yesTokenId) {
                    lastYesUpdate = update;
                }
                else if (update.assetId === noTokenId) {
                    lastNoUpdate = update;
                }
                handlers.onPriceUpdate?.(update);
                checkPairUpdate();
            },
            onBookUpdate: handlers.onBookUpdate,
            onLastTrade: handlers.onLastTrade,
            onError: handlers.onError,
        });
    }
    // ===== Price Access =====
    /**
     * Get cached price for an asset
     */
    getPrice(assetId) {
        return this.priceCache.get(assetId);
    }
    /**
     * Get all cached prices
     */
    getAllPrices() {
        return new Map(this.priceCache);
    }
    /**
     * Get cached order book for an asset
     */
    getBook(assetId) {
        return this.bookCache.get(assetId);
    }
    // ===== State Management =====
    /**
     * Get all active subscriptions
     */
    getActiveSubscriptions() {
        return Array.from(this.subscriptions.entries()).map(([id, { assetIds }]) => ({
            id,
            assetIds,
            unsubscribe: async () => {
                const entry = this.subscriptions.get(id);
                if (entry) {
                    entry.sub.unsubscribe();
                    this.subscriptions.delete(id);
                }
            },
        }));
    }
    /**
     * Unsubscribe from all markets
     */
    async unsubscribeAll() {
        for (const { sub } of this.subscriptions.values()) {
            sub.unsubscribe();
        }
        this.subscriptions.clear();
        this.priceCache.clear();
        this.bookCache.clear();
    }
    /**
     * Disconnect from WebSocket
     */
    disconnect() {
        this.v2Service.disconnect();
    }
    // ===== Private Methods =====
    /**
     * Calculate derived price from orderbook (Polymarket display logic)
     */
    calculateDerivedPrice(book) {
        const bestBid = book.bids[0]?.price || 0;
        const bestAsk = book.asks[0]?.price || 1;
        const spread = bestAsk - bestBid;
        const midpoint = (bestBid + bestAsk) / 2;
        // Polymarket display logic: use midpoint if spread <= 10%, otherwise last trade
        // For now, always use midpoint as we may not have last trade yet
        const price = midpoint;
        return {
            assetId: book.assetId,
            price,
            midpoint,
            spread,
            timestamp: book.timestamp,
        };
    }
}
//# sourceMappingURL=realtime-service.js.map