/**
 * RealtimeService V2
 *
 * Comprehensive real-time data service using official @polymarket/real-time-data-client.
 *
 * Supports ALL available topics:
 * - clob_market: price_change, agg_orderbook, last_trade_price, tick_size_change, market_created, market_resolved
 * - clob_user: order, trade (requires authentication)
 * - activity: trades, orders_matched
 * - crypto_prices: update (BTC, ETH, etc.)
 * - equity_prices: update (AAPL, etc.)
 * - comments: comment_created, comment_removed, reaction_created, reaction_removed
 * - rfq: request_*, quote_*
 */
import { EventEmitter } from 'events';
import { type ClobApiKeyCreds } from '@polymarket/real-time-data-client';
import type { PriceUpdate, BookUpdate, Orderbook } from '../core/types.js';
export interface RealtimeServiceConfig {
    /** Auto-reconnect on disconnect (default: true) */
    autoReconnect?: boolean;
    /** Ping interval in ms (default: 5000) */
    pingInterval?: number;
    /** Enable debug logging (default: false) */
    debug?: boolean;
}
/**
 * Extended orderbook snapshot from WebSocket with additional trading parameters.
 * Extends the base Orderbook type from core/types.ts.
 */
export interface OrderbookSnapshot extends Orderbook {
    /** Token ID (ERC-1155 token identifier, required in WebSocket context) */
    tokenId: string;
    /** @deprecated Use tokenId instead */
    assetId: string;
    /** Market condition ID (required in WebSocket context) */
    market: string;
    /** Tick size for price rounding */
    tickSize: string;
    /** Minimum order size */
    minOrderSize: string;
    /** Hash for change detection (required in WebSocket context) */
    hash: string;
}
export interface LastTradeInfo {
    assetId: string;
    price: number;
    side: 'BUY' | 'SELL';
    size: number;
    timestamp: number;
}
export interface PriceChange {
    assetId: string;
    changes: Array<{
        price: string;
        size: string;
    }>;
    timestamp: number;
}
export interface TickSizeChange {
    assetId: string;
    oldTickSize: string;
    newTickSize: string;
    timestamp: number;
}
export interface MarketEvent {
    conditionId: string;
    type: 'created' | 'resolved';
    data: Record<string, unknown>;
    timestamp: number;
}
export interface UserOrder {
    orderId: string;
    market: string;
    asset: string;
    side: 'BUY' | 'SELL';
    price: number;
    originalSize: number;
    matchedSize: number;
    eventType: 'PLACEMENT' | 'UPDATE' | 'CANCELLATION';
    timestamp: number;
}
export interface UserTrade {
    tradeId: string;
    market: string;
    outcome: string;
    price: number;
    size: number;
    side: 'BUY' | 'SELL';
    status: 'MATCHED' | 'MINED' | 'CONFIRMED' | 'RETRYING' | 'FAILED';
    timestamp: number;
    transactionHash?: string;
}
/**
 * Activity trade from WebSocket
 *
 * 实测验证 (2025-12-28)：proxyWallet 和 name 是顶层字段，不在 trader 对象里
 */
export interface ActivityTrade {
    /** Token ID (用于下单) */
    asset: string;
    /** Market condition ID */
    conditionId: string;
    /** Event slug */
    eventSlug: string;
    /** Market slug (可用于过滤) */
    marketSlug: string;
    /** Outcome (Yes/No) */
    outcome: string;
    /** Trade price */
    price: number;
    /** Trade side */
    side: 'BUY' | 'SELL';
    /** Trade size in shares */
    size: number;
    /** Timestamp (Unix seconds) */
    timestamp: number;
    /** Transaction hash */
    transactionHash: string;
    /**
     * Trader info object - 用于 Copy Trading 过滤目标钱包
     *
     * 注意: 实测验证 (2025-12-28) 数据结构为:
     * {
     *   trader: { name: "username", address: "0x..." }
     * }
     * 而非顶层 proxyWallet
     */
    trader?: {
        /** 交易者用户名 */
        name?: string;
        /** 交易者钱包地址 - Copy Trading 过滤关键字段！ */
        address?: string;
    };
}
export interface CryptoPrice {
    symbol: string;
    price: number;
    timestamp: number;
}
export interface EquityPrice {
    symbol: string;
    price: number;
    timestamp: number;
}
export interface Comment {
    id: string;
    parentEntityId: number;
    parentEntityType: 'Event' | 'Series';
    content?: string;
    author?: string;
    timestamp: number;
}
export interface Reaction {
    id: string;
    commentId: string;
    type: string;
    author?: string;
    timestamp: number;
}
export interface RFQRequest {
    id: string;
    market: string;
    side: 'BUY' | 'SELL';
    size: number;
    status: 'created' | 'edited' | 'canceled' | 'expired';
    timestamp: number;
}
export interface RFQQuote {
    id: string;
    requestId: string;
    price: number;
    size: number;
    status: 'created' | 'edited' | 'canceled' | 'expired';
    timestamp: number;
}
export interface Subscription {
    id: string;
    topic: string;
    type: string;
    unsubscribe: () => void;
}
export interface MarketSubscription extends Subscription {
    tokenIds: string[];
}
export interface MarketDataHandlers {
    onOrderbook?: (book: OrderbookSnapshot) => void;
    onPriceChange?: (change: PriceChange) => void;
    onLastTrade?: (trade: LastTradeInfo) => void;
    onTickSizeChange?: (change: TickSizeChange) => void;
    onMarketEvent?: (event: MarketEvent) => void;
    onError?: (error: Error) => void;
}
export interface UserDataHandlers {
    onOrder?: (order: UserOrder) => void;
    onTrade?: (trade: UserTrade) => void;
    onError?: (error: Error) => void;
}
export interface ActivityHandlers {
    onTrade?: (trade: ActivityTrade) => void;
    onError?: (error: Error) => void;
}
export interface CryptoPriceHandlers {
    onPrice?: (price: CryptoPrice) => void;
    onError?: (error: Error) => void;
}
export interface EquityPriceHandlers {
    onPrice?: (price: EquityPrice) => void;
    onError?: (error: Error) => void;
}
export declare class RealtimeServiceV2 extends EventEmitter {
    private client;
    private config;
    private subscriptions;
    private subscriptionIdCounter;
    private connected;
    private subscriptionMessages;
    private priceCache;
    private bookCache;
    private lastTradeCache;
    constructor(config?: RealtimeServiceConfig);
    /**
     * Connect to WebSocket server
     */
    connect(): this;
    /**
     * Disconnect from WebSocket server
     */
    disconnect(): void;
    /**
     * Check if connected
     */
    isConnected(): boolean;
    /**
     * Subscribe to market data (orderbook, prices, trades)
     * @param tokenIds - Array of token IDs to subscribe to
     * @param handlers - Event handlers
     */
    subscribeMarkets(tokenIds: string[], handlers?: MarketDataHandlers): MarketSubscription;
    /**
     * Subscribe to a single market (YES + NO tokens)
     * Also emits derived price updates compatible with old API
     */
    subscribeMarket(yesTokenId: string, noTokenId: string, handlers?: MarketDataHandlers & {
        onPriceUpdate?: (update: PriceUpdate) => void;
        onBookUpdate?: (update: BookUpdate) => void;
        onPairUpdate?: (update: {
            yes: PriceUpdate;
            no: PriceUpdate;
            spread: number;
        }) => void;
    }): MarketSubscription;
    /**
     * Subscribe to market lifecycle events (creation, resolution)
     */
    subscribeMarketEvents(handlers: {
        onMarketEvent?: (event: MarketEvent) => void;
    }): Subscription;
    /**
     * Subscribe to user order and trade events
     * @param credentials - CLOB API credentials
     * @param handlers - Event handlers
     */
    subscribeUserEvents(credentials: ClobApiKeyCreds, handlers?: UserDataHandlers): Subscription;
    /**
     * Subscribe to trading activity for a market or event
     * @param filter - Event or market slug (optional - if empty, subscribes to all activity)
     * @param handlers - Event handlers
     */
    subscribeActivity(filter?: {
        eventSlug?: string;
        marketSlug?: string;
    }, handlers?: ActivityHandlers): Subscription;
    /**
     * Subscribe to ALL trading activity across all markets (no filtering)
     * This is useful for Copy Trading - monitoring Smart Money across the platform
     * @param handlers - Event handlers
     */
    subscribeAllActivity(handlers?: ActivityHandlers): Subscription;
    /**
     * Subscribe to crypto price updates
     * @param symbols - Array of symbols (e.g., ['BTCUSDT', 'ETHUSDT'])
     * @param handlers - Event handlers
     */
    subscribeCryptoPrices(symbols: string[], handlers?: CryptoPriceHandlers): Subscription;
    /**
     * Subscribe to Chainlink crypto prices
     * @param symbols - Array of symbols (e.g., ['ETH/USD', 'BTC/USD'])
     */
    subscribeCryptoChainlinkPrices(symbols: string[], handlers?: CryptoPriceHandlers): Subscription;
    /**
     * Subscribe to equity price updates
     * @param symbols - Array of symbols (e.g., ['AAPL', 'GOOGL'])
     * @param handlers - Event handlers
     */
    subscribeEquityPrices(symbols: string[], handlers?: EquityPriceHandlers): Subscription;
    /**
     * Subscribe to comment and reaction events
     */
    subscribeComments(filter: {
        parentEntityId: number;
        parentEntityType: 'Event' | 'Series';
    }, handlers?: {
        onComment?: (comment: Comment) => void;
        onReaction?: (reaction: Reaction) => void;
    }): Subscription;
    /**
     * Subscribe to RFQ (Request for Quote) events
     */
    subscribeRFQ(handlers?: {
        onRequest?: (request: RFQRequest) => void;
        onQuote?: (quote: RFQQuote) => void;
    }): Subscription;
    /**
     * Get cached derived price for an asset
     */
    getPrice(assetId: string): PriceUpdate | undefined;
    /**
     * Get all cached prices
     */
    getAllPrices(): Map<string, PriceUpdate>;
    /**
     * Get cached orderbook for an asset
     */
    getBook(assetId: string): OrderbookSnapshot | undefined;
    /**
     * Get cached last trade for an asset
     */
    getLastTrade(assetId: string): LastTradeInfo | undefined;
    /**
     * Get all active subscriptions
     */
    getActiveSubscriptions(): Subscription[];
    /**
     * Unsubscribe from all
     */
    unsubscribeAll(): void;
    private handleConnect;
    private handleStatusChange;
    private handleMessage;
    private handleMarketMessage;
    private handleUserMessage;
    private handleActivityMessage;
    private handleCryptoPriceMessage;
    private handleCryptoChainlinkPriceMessage;
    private handleEquityPriceMessage;
    private handleCommentMessage;
    private handleRFQMessage;
    private parseOrderbook;
    private parsePriceChange;
    private parseLastTrade;
    private parseTickSizeChange;
    /**
     * Calculate derived price using Polymarket's display logic:
     * - If spread <= 0.10: use midpoint
     * - If spread > 0.10: use last trade price
     */
    private calculateDerivedPrice;
    private sendSubscription;
    private sendUnsubscription;
    private log;
}
//# sourceMappingURL=realtime-service-v2.d.ts.map