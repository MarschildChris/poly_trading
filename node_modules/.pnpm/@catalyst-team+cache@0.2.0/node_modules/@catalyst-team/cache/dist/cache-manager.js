export class CacheManager {
    l1;
    l2;
    stats = {
        l1Hits: 0,
        l1Misses: 0,
        l2Hits: 0,
        l2Misses: 0,
        totalHits: 0,
        totalMisses: 0,
        hitRate: 0,
    };
    constructor(options = {}) {
        this.l1 = options.l1;
        this.l2 = options.l2;
    }
    /**
     * Get a value from cache (L1 â†’ L2 fallback)
     */
    async get(key) {
        // Try L1 first
        if (this.l1) {
            try {
                const value = await this.l1.get(key);
                if (value !== null) {
                    this.stats.l1Hits++;
                    this.stats.totalHits++;
                    this.updateHitRate();
                    return value;
                }
                this.stats.l1Misses++;
            }
            catch (error) {
                console.warn('[CacheManager] L1 get failed, falling back to L2:', error);
                this.stats.l1Misses++;
            }
        }
        // Try L2 if L1 missed
        if (this.l2) {
            const value = await this.l2.get(key);
            if (value !== null) {
                this.stats.l2Hits++;
                this.stats.totalHits++;
                this.updateHitRate();
                // Backfill L1
                if (this.l1) {
                    await this.l1.set(key, value, 60).catch((error) => {
                        console.warn('[CacheManager] Failed to backfill L1:', error);
                    });
                }
                return value;
            }
            this.stats.l2Misses++;
        }
        this.stats.totalMisses++;
        this.updateHitRate();
        return null;
    }
    /**
     * Set a value in cache
     */
    async set(key, value, options) {
        const ttl = options?.ttl;
        const skipL1 = options?.skipL1 || false;
        const errors = [];
        // Write to L1 unless skipL1 is true
        if (this.l1 && !skipL1) {
            try {
                await this.l1.set(key, value, ttl);
            }
            catch (error) {
                errors.push(error);
                console.warn('[CacheManager] Failed to write to L1:', error);
            }
        }
        // Write to L2
        if (this.l2) {
            try {
                await this.l2.set(key, value, ttl);
            }
            catch (error) {
                errors.push(error);
                console.warn('[CacheManager] Failed to write to L2:', error);
            }
        }
        // Throw if all writes failed
        if (errors.length > 0 && (!this.l1 || skipL1) && !this.l2) {
            throw new Error('All cache writes failed');
        }
    }
    /**
     * Delete a value from all cache layers
     */
    async del(key) {
        const promises = [];
        if (this.l1) {
            promises.push(this.l1.del(key).catch((error) => {
                console.warn('[CacheManager] Failed to delete from L1:', error);
            }));
        }
        if (this.l2) {
            promises.push(this.l2.del(key).catch((error) => {
                console.warn('[CacheManager] Failed to delete from L2:', error);
            }));
        }
        await Promise.all(promises);
    }
    /**
     * Check if a key exists in any cache layer
     */
    async exists(key) {
        if (this.l1 && (await this.l1.exists(key))) {
            return true;
        }
        if (this.l2 && (await this.l2.exists(key))) {
            return true;
        }
        return false;
    }
    /**
     * Get or set a value (cache-aside pattern)
     */
    async getOrSet(key, factory, options) {
        // Try to get from cache
        const cached = await this.get(key);
        if (cached !== null) {
            return cached;
        }
        // Fetch from source
        const value = await factory();
        // Store in cache (don't await to avoid blocking)
        this.set(key, value, options).catch((error) => {
            console.warn('[CacheManager] Failed to cache value:', error);
        });
        return value;
    }
    /**
     * Clear all cache layers
     */
    async clear() {
        const promises = [];
        if (this.l1?.clear) {
            promises.push(this.l1.clear().catch((error) => {
                console.warn('[CacheManager] Failed to clear L1:', error);
            }));
        }
        if (this.l2?.clear) {
            promises.push(this.l2.clear().catch((error) => {
                console.warn('[CacheManager] Failed to clear L2:', error);
            }));
        }
        await Promise.all(promises);
    }
    /**
     * Get cache statistics
     */
    getStats() {
        return { ...this.stats };
    }
    /**
     * Reset cache statistics
     */
    resetStats() {
        this.stats = {
            l1Hits: 0,
            l1Misses: 0,
            l2Hits: 0,
            l2Misses: 0,
            totalHits: 0,
            totalMisses: 0,
            hitRate: 0,
        };
    }
    updateHitRate() {
        const total = this.stats.totalHits + this.stats.totalMisses;
        this.stats.hitRate = total > 0 ? this.stats.totalHits / total : 0;
    }
    /**
     * Get cache layers info
     */
    getInfo() {
        return {
            hasL1: !!this.l1,
            hasL2: !!this.l2,
        };
    }
}
//# sourceMappingURL=cache-manager.js.map