export class RedisAdapter {
    client;
    defaultTTL;
    constructor(client, options) {
        this.client = client;
        this.defaultTTL = options?.defaultTTL || 300; // Default 5 minutes
    }
    async get(key) {
        try {
            const value = await this.client.get(key);
            if (value === null)
                return null;
            // Try to parse as JSON
            try {
                return JSON.parse(value);
            }
            catch {
                // If parsing fails, return as-is (for string values)
                return value;
            }
        }
        catch (error) {
            console.error('[RedisAdapter] Error getting key:', key, error);
            return null;
        }
    }
    async set(key, value, ttl) {
        try {
            const ttlSeconds = ttl ?? this.defaultTTL;
            const serialized = typeof value === 'string' ? value : JSON.stringify(value);
            if (ttlSeconds > 0) {
                await this.client.setex(key, ttlSeconds, serialized);
            }
            else {
                await this.client.set(key, serialized);
            }
        }
        catch (error) {
            console.error('[RedisAdapter] Error setting key:', key, error);
            throw error;
        }
    }
    async del(key) {
        try {
            await this.client.del(key);
        }
        catch (error) {
            console.error('[RedisAdapter] Error deleting key:', key, error);
            throw error;
        }
    }
    async exists(key) {
        try {
            const result = await this.client.exists(key);
            return result === 1;
        }
        catch (error) {
            console.error('[RedisAdapter] Error checking key existence:', key, error);
            return false;
        }
    }
    async clear() {
        try {
            await this.client.flushdb();
        }
        catch (error) {
            console.error('[RedisAdapter] Error clearing cache:', error);
            throw error;
        }
    }
    /**
     * Get time-to-live for a key (in seconds)
     */
    async ttl(key) {
        try {
            return await this.client.ttl(key);
        }
        catch (error) {
            console.error('[RedisAdapter] Error getting TTL:', key, error);
            return -2; // Key does not exist
        }
    }
    /**
     * Set expiration time for a key
     */
    async expire(key, seconds) {
        try {
            const result = await this.client.expire(key, seconds);
            return result === 1;
        }
        catch (error) {
            console.error('[RedisAdapter] Error setting expiration:', key, error);
            return false;
        }
    }
    /**
     * Increment a numeric value
     */
    async incr(key) {
        try {
            return await this.client.incr(key);
        }
        catch (error) {
            console.error('[RedisAdapter] Error incrementing:', key, error);
            throw error;
        }
    }
    /**
     * Decrement a numeric value
     */
    async decr(key) {
        try {
            return await this.client.decr(key);
        }
        catch (error) {
            console.error('[RedisAdapter] Error decrementing:', key, error);
            throw error;
        }
    }
    /**
     * Get multiple keys at once
     */
    async mget(keys) {
        try {
            const values = await this.client.mget(...keys);
            return values.map((value) => {
                if (value === null)
                    return null;
                try {
                    return JSON.parse(value);
                }
                catch {
                    return value;
                }
            });
        }
        catch (error) {
            console.error('[RedisAdapter] Error getting multiple keys:', error);
            return keys.map(() => null);
        }
    }
    /**
     * Set multiple keys at once
     */
    async mset(entries) {
        try {
            const pipeline = this.client.pipeline();
            for (const { key, value, ttl } of entries) {
                const serialized = typeof value === 'string' ? value : JSON.stringify(value);
                const ttlSeconds = ttl ?? this.defaultTTL;
                if (ttlSeconds > 0) {
                    pipeline.setex(key, ttlSeconds, serialized);
                }
                else {
                    pipeline.set(key, serialized);
                }
            }
            await pipeline.exec();
        }
        catch (error) {
            console.error('[RedisAdapter] Error setting multiple keys:', error);
            throw error;
        }
    }
    /**
     * Delete keys matching a pattern (use with caution!)
     */
    async delPattern(pattern) {
        try {
            const keys = await this.client.keys(pattern);
            if (keys.length === 0)
                return 0;
            return await this.client.del(...keys);
        }
        catch (error) {
            console.error('[RedisAdapter] Error deleting pattern:', pattern, error);
            throw error;
        }
    }
}
//# sourceMappingURL=redis-adapter.js.map