/**
 * Cache Manager
 *
 * Three-layer cache architecture:
 * - L1 (Memory): Fastest, but lost on restart
 * - L2 (Redis): Persistent, shared across instances
 * - L3 (PostgreSQL): Long-term storage (handled by application layer)
 *
 * Data flow:
 * 1. Check L1 → return if hit
 * 2. Check L2 → return + update L1 if hit
 * 3. Fetch from source → update L1 + L2
 */
import type { CacheManagerOptions, CacheSetOptions, CacheStats } from './types.js';
export declare class CacheManager {
    private l1?;
    private l2?;
    private stats;
    constructor(options?: CacheManagerOptions);
    /**
     * Get a value from cache (L1 → L2 fallback)
     */
    get<T>(key: string): Promise<T | null>;
    /**
     * Set a value in cache
     */
    set<T>(key: string, value: T, options?: CacheSetOptions): Promise<void>;
    /**
     * Delete a value from all cache layers
     */
    del(key: string): Promise<void>;
    /**
     * Check if a key exists in any cache layer
     */
    exists(key: string): Promise<boolean>;
    /**
     * Get or set a value (cache-aside pattern)
     */
    getOrSet<T>(key: string, factory: () => Promise<T>, options?: CacheSetOptions): Promise<T>;
    /**
     * Clear all cache layers
     */
    clear(): Promise<void>;
    /**
     * Get cache statistics
     */
    getStats(): CacheStats;
    /**
     * Reset cache statistics
     */
    resetStats(): void;
    private updateHitRate;
    /**
     * Get cache layers info
     */
    getInfo(): {
        hasL1: boolean;
        hasL2: boolean;
    };
}
//# sourceMappingURL=cache-manager.d.ts.map