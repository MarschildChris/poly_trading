/**
 * Redis Client
 *
 * Manages Redis connection with:
 * - Auto-reconnection on failure
 * - Connection pool support
 * - Health check methods
 * - Error handling
 */
import Redis, { type RedisOptions } from 'ioredis';
import type { RedisClientOptions } from './types.js';

export class RedisClient {
  private client: Redis;
  private isConnected = false;
  private reconnectAttempts = 0;
  private readonly maxReconnectAttempts = 10;

  constructor(options?: RedisClientOptions) {
    const redisOptions: RedisOptions = {
      host: options?.host || process.env.REDIS_HOST || 'localhost',
      port: options?.port || Number(process.env.REDIS_PORT) || 6379,
      password: options?.password || process.env.REDIS_PASSWORD,
      db: options?.db || Number(process.env.REDIS_DB) || 0,
      keyPrefix: options?.keyPrefix,
      maxRetriesPerRequest: options?.maxRetriesPerRequest ?? 3,
      enableReadyCheck: options?.enableReadyCheck ?? true,
      enableOfflineQueue: options?.enableOfflineQueue ?? true,
      lazyConnect: options?.lazyConnect ?? false,
      retryStrategy: (times) => {
        if (times > this.maxReconnectAttempts) {
          console.error('[RedisClient] Max reconnection attempts reached');
          return null; // Stop retrying
        }
        const delay = Math.min(times * 100, 3000);
        console.log(`[RedisClient] Reconnecting in ${delay}ms (attempt ${times}/${this.maxReconnectAttempts})`);
        return delay;
      },
    };

    this.client = new Redis(redisOptions);
    this.setupEventHandlers();
  }

  private setupEventHandlers(): void {
    this.client.on('connect', () => {
      console.log('[RedisClient] Connecting to Redis...');
    });

    this.client.on('ready', () => {
      console.log('[RedisClient] Redis connection ready');
      this.isConnected = true;
      this.reconnectAttempts = 0;
    });

    this.client.on('error', (error) => {
      console.error('[RedisClient] Redis error:', error.message);
      this.isConnected = false;
    });

    this.client.on('close', () => {
      console.log('[RedisClient] Redis connection closed');
      this.isConnected = false;
    });

    this.client.on('reconnecting', (delay: number) => {
      this.reconnectAttempts++;
      console.log(`[RedisClient] Reconnecting to Redis (attempt ${this.reconnectAttempts}, delay: ${delay}ms)`);
    });

    this.client.on('end', () => {
      console.log('[RedisClient] Redis connection ended');
      this.isConnected = false;
    });
  }

  /**
   * Get the underlying ioredis client
   */
  getClient(): Redis {
    return this.client;
  }

  /**
   * Check if Redis is connected and ready
   */
  isReady(): boolean {
    return this.isConnected && this.client.status === 'ready';
  }

  /**
   * Perform a health check
   */
  async healthCheck(): Promise<{ healthy: boolean; latency?: number; error?: string }> {
    if (!this.isReady()) {
      return { healthy: false, error: 'Redis not connected' };
    }

    try {
      const start = Date.now();
      await this.client.ping();
      const latency = Date.now() - start;
      return { healthy: true, latency };
    } catch (error) {
      return {
        healthy: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }

  /**
   * Get connection info
   */
  getInfo(): {
    connected: boolean;
    status: string;
    reconnectAttempts: number;
  } {
    return {
      connected: this.isConnected,
      status: this.client.status,
      reconnectAttempts: this.reconnectAttempts,
    };
  }

  /**
   * Disconnect from Redis
   */
  async disconnect(): Promise<void> {
    await this.client.quit();
    this.isConnected = false;
  }

  /**
   * Force disconnect (for emergencies)
   */
  async forceDisconnect(): Promise<void> {
    this.client.disconnect();
    this.isConnected = false;
  }

  /**
   * Clear all keys (use with caution!)
   */
  async flushdb(): Promise<void> {
    await this.client.flushdb();
  }

  /**
   * Clear all keys in all databases (use with extreme caution!)
   */
  async flushall(): Promise<void> {
    await this.client.flushall();
  }
}
