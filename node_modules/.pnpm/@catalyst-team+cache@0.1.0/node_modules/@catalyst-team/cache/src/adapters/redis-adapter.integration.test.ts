import { describe, it, expect, beforeAll, afterAll, beforeEach } from 'vitest';
import { RedisClient } from '../redis-client.js';
import { RedisAdapter } from './redis-adapter.js';

// These tests require a running Redis instance
// Skip if Redis is not available
const REDIS_AVAILABLE = process.env.REDIS_HOST || process.env.CI === 'true';

describe.skipIf(!REDIS_AVAILABLE)('RedisAdapter Integration', () => {
  let client: RedisClient;
  let adapter: RedisAdapter;

  beforeAll(async () => {
    client = new RedisClient({
      host: process.env.REDIS_HOST || 'localhost',
      port: Number(process.env.REDIS_PORT) || 6379,
      db: 15, // Use a separate DB for tests
    });

    // Wait for connection
    await new Promise((resolve) => setTimeout(resolve, 100));

    const health = await client.healthCheck();
    if (!health.healthy) {
      throw new Error(`Redis not available: ${health.error}`);
    }

    adapter = new RedisAdapter(client.getClient(), { defaultTTL: 60 });
  });

  afterAll(async () => {
    await client.disconnect();
  });

  beforeEach(async () => {
    // Clear test database before each test
    await adapter.clear();
  });

  describe('Basic operations', () => {
    it('should set and get a value', async () => {
      await adapter.set('test:key1', 'value1');
      const value = await adapter.get<string>('test:key1');
      expect(value).toBe('value1');
    });

    it('should return null for non-existent key', async () => {
      const value = await adapter.get('test:nonexistent');
      expect(value).toBeNull();
    });

    it('should delete a value', async () => {
      await adapter.set('test:key1', 'value1');
      await adapter.del('test:key1');
      const value = await adapter.get('test:key1');
      expect(value).toBeNull();
    });

    it('should check if key exists', async () => {
      await adapter.set('test:key1', 'value1');
      expect(await adapter.exists('test:key1')).toBe(true);
      expect(await adapter.exists('test:nonexistent')).toBe(false);
    });
  });

  describe('TTL handling', () => {
    it('should respect custom TTL', async () => {
      await adapter.set('test:key1', 'value1', 1); // 1 second

      // Should exist immediately
      expect(await adapter.get('test:key1')).toBe('value1');

      // Wait for expiration
      await new Promise((resolve) => setTimeout(resolve, 1100));

      // Should be expired
      expect(await adapter.get('test:key1')).toBeNull();
    });

    it('should get TTL for a key', async () => {
      await adapter.set('test:key1', 'value1', 10);
      const ttl = await adapter.ttl('test:key1');
      expect(ttl).toBeGreaterThan(0);
      expect(ttl).toBeLessThanOrEqual(10);
    });

    it('should set expiration on existing key', async () => {
      await adapter.set('test:key1', 'value1', 60);
      const success = await adapter.expire('test:key1', 1);
      expect(success).toBe(true);

      await new Promise((resolve) => setTimeout(resolve, 1100));
      expect(await adapter.exists('test:key1')).toBe(false);
    });
  });

  describe('Data types', () => {
    it('should handle strings', async () => {
      await adapter.set('test:str', 'string value');
      expect(await adapter.get<string>('test:str')).toBe('string value');
    });

    it('should handle numbers', async () => {
      await adapter.set('test:num', 42);
      expect(await adapter.get<number>('test:num')).toBe(42);
    });

    it('should handle objects', async () => {
      const obj = { foo: 'bar', num: 123, nested: { key: 'value' } };
      await adapter.set('test:obj', obj);
      expect(await adapter.get<typeof obj>('test:obj')).toEqual(obj);
    });

    it('should handle arrays', async () => {
      const arr = [1, 2, 3, 'four', { five: 5 }];
      await adapter.set('test:arr', arr);
      expect(await adapter.get<typeof arr>('test:arr')).toEqual(arr);
    });
  });

  describe('Numeric operations', () => {
    it('should increment a value', async () => {
      await adapter.set('test:counter', '10');
      const result = await adapter.incr('test:counter');
      expect(result).toBe(11);
      expect(await adapter.get<string>('test:counter')).toBe('11');
    });

    it('should decrement a value', async () => {
      await adapter.set('test:counter', '10');
      const result = await adapter.decr('test:counter');
      expect(result).toBe(9);
      expect(await adapter.get<string>('test:counter')).toBe('9');
    });

    it('should start from 0 if key does not exist', async () => {
      const result = await adapter.incr('test:newcounter');
      expect(result).toBe(1);
    });
  });

  describe('Batch operations', () => {
    it('should get multiple keys', async () => {
      await adapter.set('test:key1', 'value1');
      await adapter.set('test:key2', 'value2');
      await adapter.set('test:key3', 'value3');

      const values = await adapter.mget<string>(['test:key1', 'test:key2', 'test:key3']);
      expect(values).toEqual(['value1', 'value2', 'value3']);
    });

    it('should return null for missing keys in mget', async () => {
      await adapter.set('test:key1', 'value1');
      const values = await adapter.mget<string>(['test:key1', 'test:missing', 'test:key3']);
      expect(values).toEqual(['value1', null, null]);
    });

    it('should set multiple keys', async () => {
      await adapter.mset([
        { key: 'test:key1', value: 'value1', ttl: 60 },
        { key: 'test:key2', value: 'value2', ttl: 60 },
        { key: 'test:key3', value: 'value3', ttl: 60 },
      ]);

      expect(await adapter.get('test:key1')).toBe('value1');
      expect(await adapter.get('test:key2')).toBe('value2');
      expect(await adapter.get('test:key3')).toBe('value3');
    });
  });

  describe('Pattern operations', () => {
    it('should delete keys matching pattern', async () => {
      await adapter.set('test:foo:1', 'value1');
      await adapter.set('test:foo:2', 'value2');
      await adapter.set('test:bar:1', 'value3');

      const deleted = await adapter.delPattern('test:foo:*');
      expect(deleted).toBe(2);

      expect(await adapter.exists('test:foo:1')).toBe(false);
      expect(await adapter.exists('test:foo:2')).toBe(false);
      expect(await adapter.exists('test:bar:1')).toBe(true);
    });
  });

  describe('Error handling', () => {
    it('should handle invalid JSON gracefully', async () => {
      // Set a raw string value directly
      await client.getClient().set('test:rawstring', 'not-json');
      const value = await adapter.get('test:rawstring');
      expect(value).toBe('not-json');
    });
  });

  describe('Persistence', () => {
    it('should persist across adapter instances', async () => {
      await adapter.set('test:persist', 'persistent-value', 60);

      // Create a new adapter with the same client
      const newAdapter = new RedisAdapter(client.getClient());
      const value = await newAdapter.get<string>('test:persist');

      expect(value).toBe('persistent-value');
    });
  });
});
