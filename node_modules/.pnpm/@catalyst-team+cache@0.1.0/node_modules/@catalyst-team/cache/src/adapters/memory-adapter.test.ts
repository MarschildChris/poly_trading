import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { MemoryAdapter } from './memory-adapter.js';

describe('MemoryAdapter', () => {
  let adapter: MemoryAdapter;

  beforeEach(() => {
    adapter = new MemoryAdapter({ defaultTTL: 60, cleanupIntervalMs: 100 });
  });

  afterEach(() => {
    adapter.destroy();
  });

  describe('Basic operations', () => {
    it('should set and get a value', async () => {
      await adapter.set('key1', 'value1');
      const value = await adapter.get<string>('key1');
      expect(value).toBe('value1');
    });

    it('should return null for non-existent key', async () => {
      const value = await adapter.get('nonexistent');
      expect(value).toBeNull();
    });

    it('should delete a value', async () => {
      await adapter.set('key1', 'value1');
      await adapter.del('key1');
      const value = await adapter.get('key1');
      expect(value).toBeNull();
    });

    it('should check if key exists', async () => {
      await adapter.set('key1', 'value1');
      expect(await adapter.exists('key1')).toBe(true);
      expect(await adapter.exists('nonexistent')).toBe(false);
    });

    it('should clear all values', async () => {
      await adapter.set('key1', 'value1');
      await adapter.set('key2', 'value2');
      await adapter.clear();
      expect(await adapter.get('key1')).toBeNull();
      expect(await adapter.get('key2')).toBeNull();
      expect(adapter.size()).toBe(0);
    });
  });

  describe('TTL handling', () => {
    it('should respect custom TTL', async () => {
      await adapter.set('key1', 'value1', 1); // 1 second

      // Should exist immediately
      expect(await adapter.get('key1')).toBe('value1');

      // Wait for expiration
      await new Promise((resolve) => setTimeout(resolve, 1100));

      // Should be expired
      expect(await adapter.get('key1')).toBeNull();
    });

    it('should use default TTL when not specified', async () => {
      const shortAdapter = new MemoryAdapter({ defaultTTL: 1 });

      await shortAdapter.set('key1', 'value1');
      expect(await shortAdapter.get('key1')).toBe('value1');

      await new Promise((resolve) => setTimeout(resolve, 1100));
      expect(await shortAdapter.get('key1')).toBeNull();

      shortAdapter.destroy();
    });

    it('should return false for expired key in exists()', async () => {
      await adapter.set('key1', 'value1', 1);
      expect(await adapter.exists('key1')).toBe(true);

      await new Promise((resolve) => setTimeout(resolve, 1100));
      expect(await adapter.exists('key1')).toBe(false);
    });
  });

  describe('Data types', () => {
    it('should handle strings', async () => {
      await adapter.set('key1', 'string value');
      expect(await adapter.get<string>('key1')).toBe('string value');
    });

    it('should handle numbers', async () => {
      await adapter.set('key1', 42);
      expect(await adapter.get<number>('key1')).toBe(42);
    });

    it('should handle objects', async () => {
      const obj = { foo: 'bar', num: 123 };
      await adapter.set('key1', obj);
      expect(await adapter.get<typeof obj>('key1')).toEqual(obj);
    });

    it('should handle arrays', async () => {
      const arr = [1, 2, 3, 'four'];
      await adapter.set('key1', arr);
      expect(await adapter.get<typeof arr>('key1')).toEqual(arr);
    });

    it('should handle null values', async () => {
      await adapter.set('key1', null);
      const value = await adapter.get('key1');
      expect(value).toBeNull();
    });
  });

  describe('Cleanup mechanism', () => {
    it('should automatically clean up expired entries', async () => {
      const cleanupAdapter = new MemoryAdapter({
        defaultTTL: 1,
        cleanupIntervalMs: 100,
      });

      // Add multiple entries
      await cleanupAdapter.set('key1', 'value1', 0.5);
      await cleanupAdapter.set('key2', 'value2', 0.5);
      await cleanupAdapter.set('key3', 'value3', 0.5);

      expect(cleanupAdapter.size()).toBe(3);

      // Wait for expiration + cleanup
      await new Promise((resolve) => setTimeout(resolve, 700));

      // Should be cleaned up
      expect(cleanupAdapter.size()).toBe(0);

      cleanupAdapter.destroy();
    });

    it('should stop cleanup on destroy', async () => {
      const cleanupAdapter = new MemoryAdapter({ cleanupIntervalMs: 50 });

      await cleanupAdapter.set('key1', 'value1', 0.1);
      cleanupAdapter.destroy();

      // Wait and verify no cleanup happens
      await new Promise((resolve) => setTimeout(resolve, 200));

      // Size should still be 1 (no cleanup after destroy)
      expect(cleanupAdapter.size()).toBe(0); // Because destroy() clears
    });
  });

  describe('Edge cases', () => {
    it('should handle overwriting existing keys', async () => {
      await adapter.set('key1', 'value1');
      await adapter.set('key1', 'value2');
      expect(await adapter.get('key1')).toBe('value2');
    });

    it('should handle large number of keys', async () => {
      const count = 1000;
      for (let i = 0; i < count; i++) {
        await adapter.set(`key${i}`, `value${i}`);
      }

      expect(adapter.size()).toBe(count);

      for (let i = 0; i < count; i++) {
        expect(await adapter.get(`key${i}`)).toBe(`value${i}`);
      }
    });

    it('should handle concurrent operations', async () => {
      const promises = [];
      for (let i = 0; i < 100; i++) {
        promises.push(adapter.set(`key${i}`, `value${i}`));
      }

      await Promise.all(promises);
      expect(adapter.size()).toBe(100);
    });
  });
});
