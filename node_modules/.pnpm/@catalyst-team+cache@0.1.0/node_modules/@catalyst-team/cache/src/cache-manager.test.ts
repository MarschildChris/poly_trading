import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { CacheManager } from './cache-manager.js';
import { MemoryAdapter } from './adapters/memory-adapter.js';
import type { CacheAdapter } from './types.js';

// Mock adapter for testing
class MockAdapter implements CacheAdapter {
  private store = new Map<string, unknown>();
  public getCalls = 0;
  public setCalls = 0;
  public shouldFail = false;

  async get<T>(key: string): Promise<T | null> {
    this.getCalls++;
    if (this.shouldFail) throw new Error('Mock adapter error');
    return (this.store.get(key) as T) || null;
  }

  async set<T>(key: string, value: T): Promise<void> {
    this.setCalls++;
    if (this.shouldFail) throw new Error('Mock adapter error');
    this.store.set(key, value);
  }

  async del(key: string): Promise<void> {
    this.store.delete(key);
  }

  async exists(key: string): Promise<boolean> {
    return this.store.has(key);
  }

  async clear(): Promise<void> {
    this.store.clear();
  }

  reset() {
    this.getCalls = 0;
    this.setCalls = 0;
    this.shouldFail = false;
    this.store.clear();
  }
}

describe('CacheManager', () => {
  let l1: MockAdapter;
  let l2: MockAdapter;
  let manager: CacheManager;

  beforeEach(() => {
    l1 = new MockAdapter();
    l2 = new MockAdapter();
    manager = new CacheManager({ l1, l2 });
  });

  afterEach(() => {
    manager.resetStats();
  });

  describe('Basic operations', () => {
    it('should get from L1 if available', async () => {
      await l1.set('key1', 'value1');

      const value = await manager.get<string>('key1');
      expect(value).toBe('value1');
      expect(l1.getCalls).toBe(1);
      expect(l2.getCalls).toBe(0); // L2 should not be called
    });

    it('should fallback to L2 if L1 misses', async () => {
      await l2.set('key1', 'value1');

      const value = await manager.get<string>('key1');
      expect(value).toBe('value1');
      expect(l1.getCalls).toBe(1); // L1 miss
      expect(l2.getCalls).toBe(1); // L2 hit
    });

    it('should backfill L1 when L2 hits', async () => {
      await l2.set('key1', 'value1');

      await manager.get<string>('key1');

      // Wait for backfill
      await new Promise((resolve) => setTimeout(resolve, 50));

      // L1 should now have the value
      expect(await l1.get('key1')).toBe('value1');
    });

    it('should return null if both layers miss', async () => {
      const value = await manager.get('nonexistent');
      expect(value).toBeNull();
      expect(l1.getCalls).toBe(1);
      expect(l2.getCalls).toBe(1);
    });
  });

  describe('Set operations', () => {
    it('should write to both L1 and L2', async () => {
      await manager.set('key1', 'value1');

      expect(await l1.get('key1')).toBe('value1');
      expect(await l2.get('key1')).toBe('value1');
      expect(l1.setCalls).toBe(1);
      expect(l2.setCalls).toBe(1);
    });

    it('should skip L1 when skipL1 is true', async () => {
      await manager.set('key1', 'value1', { skipL1: true });

      expect(await l1.get('key1')).toBeNull();
      expect(await l2.get('key1')).toBe('value1');
      expect(l1.setCalls).toBe(0);
      expect(l2.setCalls).toBe(1);
    });

    it('should pass TTL to adapters', async () => {
      const memoryAdapter = new MemoryAdapter();
      const managerWithReal = new CacheManager({ l1: memoryAdapter });

      await managerWithReal.set('key1', 'value1', { ttl: 1 });
      expect(await managerWithReal.get('key1')).toBe('value1');

      await new Promise((resolve) => setTimeout(resolve, 1100));
      expect(await managerWithReal.get('key1')).toBeNull();

      memoryAdapter.destroy();
    });
  });

  describe('Delete operations', () => {
    it('should delete from all layers', async () => {
      await l1.set('key1', 'value1');
      await l2.set('key1', 'value1');

      await manager.del('key1');

      expect(await l1.exists('key1')).toBe(false);
      expect(await l2.exists('key1')).toBe(false);
    });
  });

  describe('Exists operation', () => {
    it('should return true if key exists in L1', async () => {
      await l1.set('key1', 'value1');
      expect(await manager.exists('key1')).toBe(true);
    });

    it('should return true if key exists in L2', async () => {
      await l2.set('key1', 'value1');
      expect(await manager.exists('key1')).toBe(true);
    });

    it('should return false if key does not exist', async () => {
      expect(await manager.exists('nonexistent')).toBe(false);
    });
  });

  describe('GetOrSet pattern', () => {
    it('should return cached value if available', async () => {
      await manager.set('key1', 'cached-value');

      const factory = vi.fn(async () => 'new-value');
      const value = await manager.getOrSet('key1', factory);

      expect(value).toBe('cached-value');
      expect(factory).not.toHaveBeenCalled();
    });

    it('should call factory if cache misses', async () => {
      const factory = vi.fn(async () => 'new-value');
      const value = await manager.getOrSet('key1', factory);

      expect(value).toBe('new-value');
      expect(factory).toHaveBeenCalledOnce();

      // Wait for cache write
      await new Promise((resolve) => setTimeout(resolve, 50));

      // Should be cached now
      expect(await manager.get('key1')).toBe('new-value');
    });

    it('should handle factory errors', async () => {
      const factory = vi.fn(async () => {
        throw new Error('Factory error');
      });

      await expect(manager.getOrSet('key1', factory)).rejects.toThrow('Factory error');
    });
  });

  describe('Statistics', () => {
    it('should track L1 hits', async () => {
      await l1.set('key1', 'value1');
      await manager.get('key1');

      const stats = manager.getStats();
      expect(stats.l1Hits).toBe(1);
      expect(stats.totalHits).toBe(1);
      expect(stats.hitRate).toBe(1);
    });

    it('should track L2 hits', async () => {
      await l2.set('key1', 'value1');
      await manager.get('key1');

      const stats = manager.getStats();
      expect(stats.l1Misses).toBe(1);
      expect(stats.l2Hits).toBe(1);
      expect(stats.totalHits).toBe(1);
      expect(stats.hitRate).toBe(1);
    });

    it('should track misses', async () => {
      await manager.get('nonexistent');

      const stats = manager.getStats();
      expect(stats.l1Misses).toBe(1);
      expect(stats.l2Misses).toBe(1);
      expect(stats.totalMisses).toBe(1);
      expect(stats.hitRate).toBe(0);
    });

    it('should calculate hit rate correctly', async () => {
      await l1.set('key1', 'value1');
      await l2.set('key2', 'value2');

      await manager.get('key1'); // L1 hit
      await manager.get('key2'); // L2 hit
      await manager.get('key3'); // Miss

      const stats = manager.getStats();
      expect(stats.totalHits).toBe(2);
      expect(stats.totalMisses).toBe(1);
      expect(stats.hitRate).toBeCloseTo(2 / 3);
    });

    it('should reset statistics', async () => {
      await l1.set('key1', 'value1');
      await manager.get('key1');

      manager.resetStats();
      const stats = manager.getStats();

      expect(stats.l1Hits).toBe(0);
      expect(stats.totalHits).toBe(0);
      expect(stats.hitRate).toBe(0);
    });
  });

  describe('Error handling', () => {
    it('should continue if L1 write fails', async () => {
      l1.shouldFail = true;

      await manager.set('key1', 'value1');

      // L2 should still have the value
      expect(await l2.get('key1')).toBe('value1');
    });

    it('should continue if L2 write fails', async () => {
      l2.shouldFail = true;

      await manager.set('key1', 'value1');

      // L1 should still have the value
      expect(await l1.get('key1')).toBe('value1');
    });

    it('should handle L1 get failure gracefully', async () => {
      l1.shouldFail = true;
      await l2.set('key1', 'value1');

      const value = await manager.get('key1');
      expect(value).toBe('value1'); // Should fallback to L2
    });

    it('should not throw if delete fails', async () => {
      l1.shouldFail = true;
      await expect(manager.del('key1')).resolves.not.toThrow();
    });
  });

  describe('Clear operation', () => {
    it('should clear all layers', async () => {
      await manager.set('key1', 'value1');
      await manager.set('key2', 'value2');

      await manager.clear();

      expect(await l1.exists('key1')).toBe(false);
      expect(await l2.exists('key1')).toBe(false);
      expect(await l1.exists('key2')).toBe(false);
      expect(await l2.exists('key2')).toBe(false);
    });

    it('should handle clear errors gracefully', async () => {
      l1.shouldFail = true;
      await expect(manager.clear()).resolves.not.toThrow();
    });
  });

  describe('Single-layer scenarios', () => {
    it('should work with only L1', async () => {
      const singleManager = new CacheManager({ l1 });

      await singleManager.set('key1', 'value1');
      expect(await singleManager.get('key1')).toBe('value1');

      const stats = singleManager.getStats();
      expect(stats.l1Hits).toBe(1);
    });

    it('should work with only L2', async () => {
      const singleManager = new CacheManager({ l2 });

      await singleManager.set('key1', 'value1');
      expect(await singleManager.get('key1')).toBe('value1');

      const stats = singleManager.getStats();
      expect(stats.l2Hits).toBe(1);
    });

    it('should work with no cache layers', async () => {
      const emptyManager = new CacheManager({});

      await emptyManager.set('key1', 'value1');
      expect(await emptyManager.get('key1')).toBeNull();
    });
  });

  describe('Info method', () => {
    it('should return layer information', () => {
      const info = manager.getInfo();
      expect(info.hasL1).toBe(true);
      expect(info.hasL2).toBe(true);
    });

    it('should reflect missing layers', () => {
      const singleManager = new CacheManager({ l1 });
      const info = singleManager.getInfo();
      expect(info.hasL1).toBe(true);
      expect(info.hasL2).toBe(false);
    });
  });
});
