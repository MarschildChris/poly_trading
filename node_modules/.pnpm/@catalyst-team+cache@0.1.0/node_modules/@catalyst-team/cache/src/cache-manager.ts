/**
 * Cache Manager
 *
 * Three-layer cache architecture:
 * - L1 (Memory): Fastest, but lost on restart
 * - L2 (Redis): Persistent, shared across instances
 * - L3 (PostgreSQL): Long-term storage (handled by application layer)
 *
 * Data flow:
 * 1. Check L1 → return if hit
 * 2. Check L2 → return + update L1 if hit
 * 3. Fetch from source → update L1 + L2
 */
import type { CacheAdapter, CacheManagerOptions, CacheSetOptions, CacheStats } from './types.js';

export class CacheManager {
  private l1?: CacheAdapter;
  private l2?: CacheAdapter;
  private stats: CacheStats = {
    l1Hits: 0,
    l1Misses: 0,
    l2Hits: 0,
    l2Misses: 0,
    totalHits: 0,
    totalMisses: 0,
    hitRate: 0,
  };

  constructor(options: CacheManagerOptions = {}) {
    this.l1 = options.l1;
    this.l2 = options.l2;
  }

  /**
   * Get a value from cache (L1 → L2 fallback)
   */
  async get<T>(key: string): Promise<T | null> {
    // Try L1 first
    if (this.l1) {
      try {
        const value = await this.l1.get<T>(key);
        if (value !== null) {
          this.stats.l1Hits++;
          this.stats.totalHits++;
          this.updateHitRate();
          return value;
        }
        this.stats.l1Misses++;
      } catch (error) {
        console.warn('[CacheManager] L1 get failed, falling back to L2:', error);
        this.stats.l1Misses++;
      }
    }

    // Try L2 if L1 missed
    if (this.l2) {
      const value = await this.l2.get<T>(key);
      if (value !== null) {
        this.stats.l2Hits++;
        this.stats.totalHits++;
        this.updateHitRate();

        // Backfill L1
        if (this.l1) {
          await this.l1.set(key, value, 60).catch((error) => {
            console.warn('[CacheManager] Failed to backfill L1:', error);
          });
        }

        return value;
      }
      this.stats.l2Misses++;
    }

    this.stats.totalMisses++;
    this.updateHitRate();
    return null;
  }

  /**
   * Set a value in cache
   */
  async set<T>(key: string, value: T, options?: CacheSetOptions): Promise<void> {
    const ttl = options?.ttl;
    const skipL1 = options?.skipL1 || false;

    const errors: Error[] = [];

    // Write to L1 unless skipL1 is true
    if (this.l1 && !skipL1) {
      try {
        await this.l1.set(key, value, ttl);
      } catch (error) {
        errors.push(error as Error);
        console.warn('[CacheManager] Failed to write to L1:', error);
      }
    }

    // Write to L2
    if (this.l2) {
      try {
        await this.l2.set(key, value, ttl);
      } catch (error) {
        errors.push(error as Error);
        console.warn('[CacheManager] Failed to write to L2:', error);
      }
    }

    // Throw if all writes failed
    if (errors.length > 0 && (!this.l1 || skipL1) && !this.l2) {
      throw new Error('All cache writes failed');
    }
  }

  /**
   * Delete a value from all cache layers
   */
  async del(key: string): Promise<void> {
    const promises: Promise<void>[] = [];

    if (this.l1) {
      promises.push(
        this.l1.del(key).catch((error) => {
          console.warn('[CacheManager] Failed to delete from L1:', error);
        })
      );
    }

    if (this.l2) {
      promises.push(
        this.l2.del(key).catch((error) => {
          console.warn('[CacheManager] Failed to delete from L2:', error);
        })
      );
    }

    await Promise.all(promises);
  }

  /**
   * Check if a key exists in any cache layer
   */
  async exists(key: string): Promise<boolean> {
    if (this.l1 && (await this.l1.exists(key))) {
      return true;
    }

    if (this.l2 && (await this.l2.exists(key))) {
      return true;
    }

    return false;
  }

  /**
   * Get or set a value (cache-aside pattern)
   */
  async getOrSet<T>(
    key: string,
    factory: () => Promise<T>,
    options?: CacheSetOptions
  ): Promise<T> {
    // Try to get from cache
    const cached = await this.get<T>(key);
    if (cached !== null) {
      return cached;
    }

    // Fetch from source
    const value = await factory();

    // Store in cache (don't await to avoid blocking)
    this.set(key, value, options).catch((error) => {
      console.warn('[CacheManager] Failed to cache value:', error);
    });

    return value;
  }

  /**
   * Clear all cache layers
   */
  async clear(): Promise<void> {
    const promises: Promise<void>[] = [];

    if (this.l1?.clear) {
      promises.push(
        this.l1.clear().catch((error) => {
          console.warn('[CacheManager] Failed to clear L1:', error);
        })
      );
    }

    if (this.l2?.clear) {
      promises.push(
        this.l2.clear().catch((error) => {
          console.warn('[CacheManager] Failed to clear L2:', error);
        })
      );
    }

    await Promise.all(promises);
  }

  /**
   * Get cache statistics
   */
  getStats(): CacheStats {
    return { ...this.stats };
  }

  /**
   * Reset cache statistics
   */
  resetStats(): void {
    this.stats = {
      l1Hits: 0,
      l1Misses: 0,
      l2Hits: 0,
      l2Misses: 0,
      totalHits: 0,
      totalMisses: 0,
      hitRate: 0,
    };
  }

  private updateHitRate(): void {
    const total = this.stats.totalHits + this.stats.totalMisses;
    this.stats.hitRate = total > 0 ? this.stats.totalHits / total : 0;
  }

  /**
   * Get cache layers info
   */
  getInfo(): { hasL1: boolean; hasL2: boolean } {
    return {
      hasL1: !!this.l1,
      hasL2: !!this.l2,
    };
  }
}
