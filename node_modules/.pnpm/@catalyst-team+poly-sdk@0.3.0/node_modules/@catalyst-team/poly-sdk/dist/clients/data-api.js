/**
 * Data API Client for Polymarket
 * Handles: positions, activity, trades, leaderboard
 */
import { ApiType } from '../core/rate-limiter.js';
import { CACHE_TTL } from '../core/unified-cache.js';
import { PolymarketError } from '../core/errors.js';
const DATA_API_BASE = 'https://data-api.polymarket.com';
// ===== Client =====
export class DataApiClient {
    rateLimiter;
    cache;
    constructor(rateLimiter, cache) {
        this.rateLimiter = rateLimiter;
        this.cache = cache;
    }
    // ===== Wallet-related =====
    /**
     * Get positions for a wallet address
     *
     * @param address - Wallet address
     * @param params - Query parameters (P0/P1: limit, offset, sortBy, sortDirection, market, etc.)
     *
     * @example
     * ```typescript
     * // Get all positions
     * const positions = await client.getPositions(address);
     *
     * // Get positions sorted by PnL (highest first)
     * const topPnl = await client.getPositions(address, {
     *   sortBy: 'CASHPNL',
     *   sortDirection: 'DESC',
     *   limit: 10,
     * });
     *
     * // Get only redeemable positions
     * const redeemable = await client.getPositions(address, { redeemable: true });
     * ```
     */
    async getPositions(address, params) {
        return this.rateLimiter.execute(ApiType.DATA_API, async () => {
            const query = new URLSearchParams({ user: address });
            // P0: limit, offset
            if (params?.limit !== undefined)
                query.set('limit', String(params.limit));
            if (params?.offset !== undefined)
                query.set('offset', String(params.offset));
            // P1: sortBy, sortDirection, market
            if (params?.sortBy)
                query.set('sortBy', params.sortBy);
            if (params?.sortDirection)
                query.set('sortDirection', params.sortDirection);
            if (params?.market) {
                params.market.forEach((m) => query.append('market', m));
            }
            if (params?.eventId) {
                params.eventId.forEach((id) => query.append('eventId', String(id)));
            }
            // P1: sizeThreshold, redeemable, mergeable, title
            if (params?.sizeThreshold !== undefined)
                query.set('sizeThreshold', String(params.sizeThreshold));
            if (params?.redeemable !== undefined)
                query.set('redeemable', String(params.redeemable));
            if (params?.mergeable !== undefined)
                query.set('mergeable', String(params.mergeable));
            if (params?.title)
                query.set('title', params.title);
            const response = await fetch(`${DATA_API_BASE}/positions?${query}`);
            if (!response.ok)
                throw PolymarketError.fromHttpError(response.status, await response.json().catch(() => null));
            const data = (await response.json());
            return this.normalizePositions(data);
        });
    }
    /**
     * Get closed positions for a wallet address
     *
     * @param address - Wallet address
     * @param params - Query parameters
     *
     * @example
     * ```typescript
     * // Get closed positions sorted by realized PnL
     * const closed = await client.getClosedPositions(address);
     *
     * // Get recent settlements
     * const recent = await client.getClosedPositions(address, {
     *   sortBy: 'TIMESTAMP',
     *   sortDirection: 'DESC',
     *   limit: 20,
     * });
     * ```
     */
    async getClosedPositions(address, params) {
        return this.rateLimiter.execute(ApiType.DATA_API, async () => {
            const query = new URLSearchParams({ user: address });
            // Pagination
            if (params?.limit !== undefined)
                query.set('limit', String(params.limit));
            if (params?.offset !== undefined)
                query.set('offset', String(params.offset));
            // Filters
            if (params?.market) {
                params.market.forEach((m) => query.append('market', m));
            }
            if (params?.eventId) {
                params.eventId.forEach((id) => query.append('eventId', String(id)));
            }
            if (params?.title)
                query.set('title', params.title);
            // Sorting
            if (params?.sortBy)
                query.set('sortBy', params.sortBy);
            if (params?.sortDirection)
                query.set('sortDirection', params.sortDirection);
            const response = await fetch(`${DATA_API_BASE}/closed-positions?${query}`);
            if (!response.ok)
                throw PolymarketError.fromHttpError(response.status, await response.json().catch(() => null));
            const data = (await response.json());
            return this.normalizeClosedPositions(data);
        });
    }
    /**
     * Get activity for a wallet address
     *
     * @param address - Wallet address
     * @param params - Query parameters (P0: start, end, offset; P1: market, sortBy, etc.)
     *
     * @example
     * ```typescript
     * // Get recent activity
     * const activity = await client.getActivity(address, { limit: 50 });
     *
     * // Get activity in a time range (Unix seconds)
     * const dayAgo = Math.floor(Date.now() / 1000) - 86400;
     * const recent = await client.getActivity(address, {
     *   start: dayAgo,
     *   limit: 100,
     * });
     *
     * // Paginate through all activity
     * const page2 = await client.getActivity(address, { offset: 100, limit: 100 });
     * ```
     */
    async getActivity(address, params) {
        return this.rateLimiter.execute(ApiType.DATA_API, async () => {
            const query = new URLSearchParams({ user: address });
            // Basic params
            query.set('limit', String(params?.limit ?? 100));
            // P0: offset, start, end (time filtering and pagination)
            if (params?.offset !== undefined)
                query.set('offset', String(params.offset));
            if (params?.start !== undefined)
                query.set('start', String(params.start));
            if (params?.end !== undefined)
                query.set('end', String(params.end));
            // P1: type, side, market, eventId
            if (params?.type)
                query.set('type', params.type);
            if (params?.side)
                query.set('side', params.side);
            if (params?.market) {
                params.market.forEach((m) => query.append('market', m));
            }
            if (params?.eventId) {
                params.eventId.forEach((id) => query.append('eventId', String(id)));
            }
            // P2: sortBy, sortDirection
            if (params?.sortBy)
                query.set('sortBy', params.sortBy);
            if (params?.sortDirection)
                query.set('sortDirection', params.sortDirection);
            const response = await fetch(`${DATA_API_BASE}/activity?${query}`);
            if (!response.ok)
                throw PolymarketError.fromHttpError(response.status, await response.json().catch(() => null));
            const data = (await response.json());
            return this.normalizeActivities(data);
        });
    }
    /**
     * Get all activity for a wallet (auto-pagination)
     *
     * @param address - Wallet address
     * @param params - Query parameters
     * @param maxItems - Maximum items to fetch (default: 10000)
     *
     * @example
     * ```typescript
     * // Get all activity since a specific date
     * const startDate = Math.floor(new Date('2024-12-01').getTime() / 1000);
     * const allActivity = await client.getAllActivity(address, { start: startDate });
     * ```
     */
    async getAllActivity(address, params, maxItems = 10000) {
        const all = [];
        const limit = 500; // Max allowed by API
        let offset = 0;
        while (all.length < maxItems) {
            const page = await this.getActivity(address, { ...params, limit, offset });
            all.push(...page);
            if (page.length < limit)
                break; // No more data
            offset += limit;
        }
        return all.slice(0, maxItems);
    }
    // ===== Trade-related =====
    /**
     * Get recent trades
     *
     * @param params - Query parameters (P2: user, side, takerOnly, etc.)
     *
     * @example
     * ```typescript
     * // Get market trades
     * const trades = await client.getTrades({ market: conditionId, limit: 100 });
     *
     * // Get user trades (P2)
     * const userTrades = await client.getTrades({ user: address, limit: 50 });
     *
     * // Get only buy trades
     * const buys = await client.getTrades({ market: conditionId, side: 'BUY' });
     * ```
     */
    async getTrades(params) {
        return this.rateLimiter.execute(ApiType.DATA_API, async () => {
            const query = new URLSearchParams();
            query.set('limit', String(params?.limit ?? 500));
            // Basic filters
            if (params?.market)
                query.set('market', params.market);
            // P2: user filter
            if (params?.user)
                query.set('user', params.user);
            // P2: additional filters
            if (params?.side)
                query.set('side', params.side);
            if (params?.takerOnly !== undefined)
                query.set('takerOnly', String(params.takerOnly));
            if (params?.filterType)
                query.set('filterType', params.filterType);
            if (params?.filterAmount !== undefined)
                query.set('filterAmount', String(params.filterAmount));
            const response = await fetch(`${DATA_API_BASE}/trades?${query}`);
            if (!response.ok)
                throw PolymarketError.fromHttpError(response.status, await response.json().catch(() => null));
            const data = (await response.json());
            return this.normalizeTrades(data);
        });
    }
    /**
     * Get trades for a specific market
     */
    async getTradesByMarket(conditionId, limit = 500) {
        return this.getTrades({ market: conditionId, limit });
    }
    /**
     * Get trades for a specific user (P2)
     */
    async getTradesByUser(address, params) {
        return this.getTrades({ ...params, user: address });
    }
    // ===== Leaderboard =====
    /**
     * Get leaderboard page with time period and ordering support
     *
     * @param params - Query parameters
     * @param params.timePeriod - Time period: 'DAY', 'WEEK', 'MONTH', 'ALL' (default: 'ALL' for backward compatibility)
     * @param params.orderBy - Order by: 'PNL', 'VOL' (default: 'PNL')
     * @param params.category - Category filter (default: 'OVERALL')
     * @param params.limit - Max entries per page (1-50, default: 50)
     * @param params.offset - Pagination offset (0-1000, default: 0)
     *
     * @example
     * ```typescript
     * // Get today's top traders by PnL
     * const daily = await client.getLeaderboard({ timePeriod: 'DAY', orderBy: 'PNL' });
     *
     * // Get this week's top traders by volume
     * const weekly = await client.getLeaderboard({ timePeriod: 'WEEK', orderBy: 'VOL' });
     *
     * // Get politics category leaderboard
     * const politics = await client.getLeaderboard({ category: 'POLITICS' });
     * ```
     */
    async getLeaderboard(params) {
        const { timePeriod = 'ALL', // Default to ALL for backward compatibility
        orderBy = 'PNL', category = 'OVERALL', limit = 50, offset = 0, user, userName, } = params || {};
        const cacheKey = `leaderboard:${timePeriod}:${orderBy}:${category}:${offset}:${limit}`;
        return this.cache.getOrSet(cacheKey, CACHE_TTL.LEADERBOARD, async () => {
            const query = new URLSearchParams({
                timePeriod,
                orderBy,
                category,
                limit: String(limit),
                offset: String(offset),
            });
            if (user)
                query.set('user', user);
            if (userName)
                query.set('userName', userName);
            return this.rateLimiter.execute(ApiType.DATA_API, async () => {
                const response = await fetch(`${DATA_API_BASE}/v1/leaderboard?${query}`);
                if (!response.ok)
                    throw PolymarketError.fromHttpError(response.status, await response.json().catch(() => null));
                const data = (await response.json());
                const entries = this.normalizeLeaderboardEntries(data);
                return {
                    entries,
                    total: entries.length + offset, // Approximate - API doesn't provide total
                    offset,
                    limit,
                };
            });
        });
    }
    /**
     * Get all leaderboard entries up to a max count
     */
    async getAllLeaderboard(maxEntries = 500) {
        const all = [];
        let offset = 0;
        const limit = 50;
        while (all.length < maxEntries) {
            const page = await this.getLeaderboard({ limit, offset });
            all.push(...page.entries);
            if (page.entries.length < limit)
                break;
            offset += limit;
        }
        return all.slice(0, maxEntries);
    }
    // ===== Value & Holders (P1/P2) =====
    /**
     * Get account total value (P1)
     *
     * @param address - Wallet address
     * @param markets - Optional: filter by specific markets
     *
     * @example
     * ```typescript
     * const { value } = await client.getAccountValue(address);
     * console.log(`Total account value: $${value.toFixed(2)}`);
     * ```
     */
    async getAccountValue(address, markets) {
        return this.rateLimiter.execute(ApiType.DATA_API, async () => {
            const query = new URLSearchParams({ user: address });
            if (markets) {
                markets.forEach((m) => query.append('market', m));
            }
            const response = await fetch(`${DATA_API_BASE}/value?${query}`);
            if (!response.ok)
                throw PolymarketError.fromHttpError(response.status, await response.json().catch(() => null));
            // API returns array: [{ user, value }]
            const data = (await response.json());
            if (Array.isArray(data) && data.length > 0) {
                return {
                    user: String(data[0].user),
                    value: Number(data[0].value) || 0,
                };
            }
            return { user: address, value: 0 };
        });
    }
    /**
     * Get market holders (P2)
     *
     * Returns top holders for a specific market. Note: This endpoint can timeout
     * for large markets.
     *
     * @param params - Query parameters (market is required)
     *
     * @example
     * ```typescript
     * const holders = await client.getMarketHolders({
     *   market: conditionId,
     *   limit: 20,
     * });
     * ```
     */
    async getMarketHolders(params) {
        return this.rateLimiter.execute(ApiType.DATA_API, async () => {
            const query = new URLSearchParams({ market: params.market });
            if (params.limit !== undefined)
                query.set('limit', String(params.limit));
            const response = await fetch(`${DATA_API_BASE}/holders?${query}`);
            if (!response.ok)
                throw PolymarketError.fromHttpError(response.status, await response.json().catch(() => null));
            const data = (await response.json());
            return this.normalizeHolders(data);
        });
    }
    // ===== Data Normalization =====
    normalizePositions(data) {
        if (!Array.isArray(data))
            return [];
        return data.map((item) => {
            const p = item;
            return {
                // Wallet identifier
                proxyWallet: p.proxyWallet !== undefined ? String(p.proxyWallet) : undefined,
                // Core identifiers
                asset: String(p.asset || ''),
                conditionId: String(p.conditionId || ''),
                outcome: String(p.outcome || ''),
                outcomeIndex: typeof p.outcomeIndex === 'number'
                    ? p.outcomeIndex
                    : p.outcome === 'Yes'
                        ? 0
                        : 1,
                // Position data
                size: Number(p.size),
                avgPrice: Number(p.avgPrice),
                curPrice: p.curPrice !== undefined ? Number(p.curPrice) : undefined,
                totalBought: p.totalBought !== undefined ? Number(p.totalBought) : undefined,
                // Value calculations
                initialValue: p.initialValue !== undefined ? Number(p.initialValue) : undefined,
                currentValue: p.currentValue !== undefined ? Number(p.currentValue) : undefined,
                cashPnl: p.cashPnl !== undefined ? Number(p.cashPnl) : undefined,
                percentPnl: p.percentPnl !== undefined ? Number(p.percentPnl) : undefined,
                realizedPnl: p.realizedPnl !== undefined ? Number(p.realizedPnl) : undefined,
                percentRealizedPnl: p.percentRealizedPnl !== undefined ? Number(p.percentRealizedPnl) : undefined,
                // Market metadata
                title: String(p.title || ''),
                slug: p.slug !== undefined ? String(p.slug) : undefined,
                icon: p.icon !== undefined ? String(p.icon) : undefined,
                eventId: p.eventId !== undefined ? String(p.eventId) : undefined,
                eventSlug: p.eventSlug !== undefined ? String(p.eventSlug) : undefined,
                // Opposite side info
                oppositeOutcome: p.oppositeOutcome !== undefined ? String(p.oppositeOutcome) : undefined,
                oppositeAsset: p.oppositeAsset !== undefined ? String(p.oppositeAsset) : undefined,
                // Status fields
                redeemable: p.redeemable !== undefined ? Boolean(p.redeemable) : undefined,
                mergeable: p.mergeable !== undefined ? Boolean(p.mergeable) : undefined,
                endDate: p.endDate !== undefined ? String(p.endDate) : undefined,
                negativeRisk: p.negativeRisk !== undefined ? Boolean(p.negativeRisk) : undefined,
            };
        });
    }
    normalizeClosedPositions(data) {
        if (!Array.isArray(data))
            return [];
        return data.map((item) => {
            const p = item;
            return {
                proxyWallet: String(p.proxyWallet || ''),
                asset: String(p.asset || ''),
                conditionId: String(p.conditionId || ''),
                // Trade data
                avgPrice: Number(p.avgPrice) || 0,
                totalBought: Number(p.totalBought) || 0,
                realizedPnl: Number(p.realizedPnl) || 0,
                curPrice: Number(p.curPrice) || 0,
                timestamp: this.normalizeTimestamp(p.timestamp),
                // Market info
                title: String(p.title || ''),
                slug: p.slug !== undefined ? String(p.slug) : undefined,
                icon: p.icon !== undefined ? String(p.icon) : undefined,
                eventSlug: p.eventSlug !== undefined ? String(p.eventSlug) : undefined,
                outcome: String(p.outcome || ''),
                outcomeIndex: typeof p.outcomeIndex === 'number'
                    ? p.outcomeIndex
                    : p.outcome === 'Yes'
                        ? 0
                        : 1,
                oppositeOutcome: p.oppositeOutcome !== undefined ? String(p.oppositeOutcome) : undefined,
                oppositeAsset: p.oppositeAsset !== undefined ? String(p.oppositeAsset) : undefined,
                endDate: p.endDate !== undefined ? String(p.endDate) : undefined,
            };
        });
    }
    normalizeActivities(data) {
        if (!Array.isArray(data))
            return [];
        return data.map((item) => {
            const a = item;
            return {
                // Transaction type
                type: String(a.type),
                side: String(a.side),
                // Trade data
                size: Number(a.size),
                price: Number(a.price),
                usdcSize: a.usdcSize !== undefined
                    ? Number(a.usdcSize)
                    : Number(a.size) * Number(a.price),
                // Market identifiers
                asset: String(a.asset || ''),
                conditionId: String(a.conditionId || ''),
                outcome: String(a.outcome || ''),
                outcomeIndex: a.outcomeIndex !== undefined ? Number(a.outcomeIndex) : undefined,
                // Transaction info
                timestamp: this.normalizeTimestamp(a.timestamp),
                transactionHash: String(a.transactionHash || ''),
                // Market metadata
                title: a.title !== undefined ? String(a.title) : undefined,
                slug: a.slug !== undefined ? String(a.slug) : undefined,
                // Trader info
                name: a.name !== undefined ? String(a.name) : undefined,
            };
        });
    }
    normalizeTrades(data) {
        if (!Array.isArray(data))
            return [];
        return data.map((item) => {
            const t = item;
            return {
                // Identifiers
                id: t.id !== undefined ? String(t.id) : undefined,
                market: String(t.market || t.conditionId || ''),
                asset: String(t.asset || ''),
                // Trade data
                side: String(t.side),
                price: Number(t.price),
                size: Number(t.size),
                outcome: String(t.outcome || ''),
                outcomeIndex: typeof t.outcomeIndex === 'number'
                    ? t.outcomeIndex
                    : t.outcome === 'Yes'
                        ? 0
                        : 1,
                // Transaction info
                timestamp: this.normalizeTimestamp(t.timestamp),
                transactionHash: String(t.transactionHash || ''),
                proxyWallet: t.proxyWallet !== undefined ? String(t.proxyWallet) : undefined,
                // Market metadata
                title: t.title !== undefined ? String(t.title) : undefined,
                slug: t.slug !== undefined ? String(t.slug) : undefined,
                icon: t.icon !== undefined ? String(t.icon) : undefined,
                eventSlug: t.eventSlug !== undefined ? String(t.eventSlug) : undefined,
                // Trader info
                name: t.name !== undefined ? String(t.name) : undefined,
                pseudonym: t.pseudonym !== undefined ? String(t.pseudonym) : undefined,
                bio: t.bio !== undefined ? String(t.bio) : undefined,
                profileImage: t.profileImage !== undefined ? String(t.profileImage) : undefined,
                profileImageOptimized: t.profileImageOptimized !== undefined ? String(t.profileImageOptimized) : undefined,
            };
        });
    }
    normalizeTimestamp(ts) {
        if (typeof ts === 'number') {
            // If timestamp is in seconds, convert to milliseconds
            return ts < 1e12 ? ts * 1000 : ts;
        }
        if (typeof ts === 'string') {
            const num = parseInt(ts, 10);
            return num < 1e12 ? num * 1000 : num;
        }
        return Date.now();
    }
    normalizeLeaderboardEntries(data) {
        if (!Array.isArray(data))
            return [];
        return data.map((item) => {
            const e = item;
            return {
                // Wallet identifier
                address: String(e.proxyWallet || e.address || ''),
                // Ranking data
                rank: typeof e.rank === 'number' ? e.rank : parseInt(String(e.rank), 10) || 0,
                pnl: Number(e.pnl) || 0,
                volume: Number(e.vol || e.volume) || 0,
                // User profile
                userName: e.userName !== undefined ? String(e.userName) : undefined,
                xUsername: e.xUsername !== undefined ? String(e.xUsername) : undefined,
                verifiedBadge: Boolean(e.verifiedBadge),
                profileImage: e.profileImage !== undefined ? String(e.profileImage) : undefined,
                // Activity counts (optional - API often returns null)
                positions: e.positions != null ? Number(e.positions) : undefined,
                trades: e.trades != null ? Number(e.trades) : undefined,
            };
        });
    }
    normalizeHolders(data) {
        if (!Array.isArray(data))
            return [];
        return data.map((item) => {
            const h = item;
            return {
                proxyWallet: String(h.proxyWallet || h.address || ''),
                size: Number(h.size) || 0,
                outcome: String(h.outcome || ''),
                value: h.value !== undefined ? Number(h.value) : undefined,
                userName: h.userName !== undefined ? String(h.userName) : undefined,
                profileImage: h.profileImage !== undefined ? String(h.profileImage) : undefined,
            };
        });
    }
}
//# sourceMappingURL=data-api.js.map