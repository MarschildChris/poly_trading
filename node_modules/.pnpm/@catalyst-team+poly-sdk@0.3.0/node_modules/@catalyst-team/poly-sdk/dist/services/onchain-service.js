/**
 * OnchainService - Unified interface for all on-chain operations
 *
 * Consolidates:
 * - CTF operations (split, merge, redeem)
 * - Authorization (ERC20/ERC1155 approvals)
 * - Swaps (QuickSwap V3)
 *
 * This service provides a single entry point for all blockchain interactions
 * required for Polymarket trading. It shares wallet/provider configuration
 * across all underlying services.
 *
 * @example
 * ```typescript
 * const onchain = new OnchainService({
 *   privateKey: '0x...',
 *   rpcUrl: 'https://polygon-rpc.com', // optional
 * });
 *
 * // Check if ready for trading
 * const status = await onchain.checkReadyForCTF('100');
 * if (!status.ready) {
 *   // Set up approvals
 *   await onchain.approveAll();
 * }
 *
 * // Execute CTF operations
 * await onchain.split(conditionId, '100');
 * await onchain.merge(conditionId, '100');
 *
 * // Swap tokens
 * await onchain.swap('MATIC', 'USDC_E', '10');
 * ```
 */
import { ethers } from 'ethers';
// Import underlying services
import { CTFClient, } from '../clients/ctf-client.js';
import { AuthorizationService, } from './authorization-service.js';
import { SwapService, } from './swap-service.js';
// ===== OnchainService =====
/**
 * Unified service for all on-chain operations on Polymarket
 *
 * This service wraps:
 * - CTFClient: Conditional Token Framework operations (split, merge, redeem)
 * - AuthorizationService: ERC20 and ERC1155 approvals
 * - SwapService: DEX swaps on Polygon via QuickSwap V3
 *
 * All services share the same wallet and provider configuration.
 */
export class OnchainService {
    wallet;
    provider;
    ctfClient;
    authService;
    swapService;
    constructor(config) {
        const rpcUrl = config.rpcUrl || 'https://polygon-rpc.com';
        // Create shared provider and wallet
        this.provider = new ethers.providers.JsonRpcProvider(rpcUrl);
        this.wallet = new ethers.Wallet(config.privateKey, this.provider);
        // Initialize CTFClient with config
        const ctfConfig = {
            privateKey: config.privateKey,
            rpcUrl,
            chainId: config.chainId,
            gasPriceMultiplier: config.gasPriceMultiplier,
            confirmations: config.confirmations,
            txTimeout: config.txTimeout,
        };
        this.ctfClient = new CTFClient(ctfConfig);
        // Initialize AuthorizationService with shared wallet
        this.authService = new AuthorizationService(this.wallet, {
            provider: this.provider,
        });
        // Initialize SwapService with shared wallet
        this.swapService = new SwapService(this.wallet);
    }
    // ===== Utilities =====
    /**
     * Get the wallet address
     */
    getAddress() {
        return this.wallet.address;
    }
    /**
     * Get native MATIC balance
     */
    async getMaticBalance() {
        const balance = await this.provider.getBalance(this.wallet.address);
        return ethers.utils.formatEther(balance);
    }
    /**
     * Get all token balances
     */
    async getTokenBalances() {
        const balances = await this.swapService.getBalances();
        const findBalance = (token) => {
            const entry = balances.find(b => b.token === token);
            return entry?.balance || '0';
        };
        return {
            matic: findBalance('MATIC'),
            usdc: findBalance('USDC'),
            usdcE: findBalance('USDC_E'),
            usdt: findBalance('USDT'),
            dai: findBalance('DAI'),
            weth: findBalance('WETH'),
            wmatic: findBalance('WMATIC'),
        };
    }
    // ===== Authorization =====
    /**
     * Check all ERC20 and ERC1155 allowances required for trading
     *
     * @returns Status of all allowances and whether trading is ready
     */
    async checkAllowances() {
        return this.authService.checkAllowances();
    }
    /**
     * Set up all required approvals for trading
     *
     * @returns Results of all approval transactions
     */
    async approveAll() {
        return this.authService.approveAll();
    }
    /**
     * Approve USDC spending for a specific contract
     */
    async approveUsdc(spenderAddress, amount = ethers.constants.MaxUint256) {
        return this.authService.approveUsdc(spenderAddress, amount);
    }
    /**
     * Set approval for an ERC1155 operator
     */
    async setErc1155Approval(operatorAddress, approved = true) {
        return this.authService.setErc1155Approval(operatorAddress, approved);
    }
    // ===== CTF Operations =====
    /**
     * Split USDC into YES + NO tokens
     *
     * @param conditionId - Market condition ID
     * @param amount - USDC amount (e.g., "100" for 100 USDC)
     * @returns SplitResult with transaction details
     */
    async split(conditionId, amount) {
        return this.ctfClient.split(conditionId, amount);
    }
    /**
     * Merge YES + NO tokens back to USDC
     *
     * @param conditionId - Market condition ID
     * @param amount - Number of token pairs to merge
     * @returns MergeResult with transaction details
     */
    async merge(conditionId, amount) {
        return this.ctfClient.merge(conditionId, amount);
    }
    /**
     * Merge YES and NO tokens using explicit token IDs
     *
     * Use this for Polymarket CLOB markets where token IDs
     * don't match the calculated position IDs.
     */
    async mergeByTokenIds(conditionId, tokenIds, amount) {
        return this.ctfClient.mergeByTokenIds(conditionId, tokenIds, amount);
    }
    /**
     * Redeem winning tokens after market resolution (Standard CTF)
     *
     * WARNING: Use redeemByTokenIds for Polymarket CLOB markets.
     */
    async redeem(conditionId, outcome) {
        return this.ctfClient.redeem(conditionId, outcome);
    }
    /**
     * Redeem winning tokens using Polymarket token IDs (Polymarket CLOB)
     *
     * This is the correct method for Polymarket CLOB markets.
     */
    async redeemByTokenIds(conditionId, tokenIds, outcome) {
        return this.ctfClient.redeemByTokenIds(conditionId, tokenIds, outcome);
    }
    // ===== Balances =====
    /**
     * Get USDC.e (bridged USDC) balance - the token used by Polymarket CTF
     */
    async getUsdcBalance() {
        return this.ctfClient.getUsdcBalance();
    }
    /**
     * Get native USDC balance (not compatible with CTF)
     */
    async getNativeUsdcBalance() {
        return this.ctfClient.getNativeUsdcBalance();
    }
    /**
     * Get token balances for a market using calculated position IDs
     *
     * @deprecated Use getPositionBalanceByTokenIds for CLOB markets
     */
    async getPositionBalance(conditionId) {
        return this.ctfClient.getPositionBalance(conditionId);
    }
    /**
     * Get token balances using CLOB API token IDs
     *
     * This is the recommended method for checking balances when working with
     * Polymarket CLOB markets.
     */
    async getPositionBalanceByTokenIds(conditionId, tokenIds) {
        return this.ctfClient.getPositionBalanceByTokenIds(conditionId, tokenIds);
    }
    /**
     * Check if wallet is ready for CTF trading operations
     *
     * Combines CTF readiness check with authorization status.
     */
    async checkReadyForCTF(amount) {
        // Check CTF readiness (balances)
        const ctfStatus = await this.ctfClient.checkReadyForCTF(amount);
        // Check authorization status
        const authStatus = await this.authService.checkAllowances();
        // Combine issues
        const issues = [];
        if (ctfStatus.suggestion) {
            issues.push(ctfStatus.suggestion);
        }
        issues.push(...authStatus.issues);
        return {
            ready: ctfStatus.ready && authStatus.tradingReady,
            usdcEBalance: ctfStatus.usdcEBalance,
            nativeUsdcBalance: ctfStatus.nativeUsdcBalance,
            maticBalance: ctfStatus.maticBalance,
            tradingReady: authStatus.tradingReady,
            issues,
            suggestion: ctfStatus.suggestion,
        };
    }
    /**
     * Check if wallet has sufficient tokens for merge
     */
    async canMerge(conditionId, amount) {
        return this.ctfClient.canMerge(conditionId, amount);
    }
    /**
     * Check if wallet has sufficient tokens for merge using CLOB token IDs
     */
    async canMergeWithTokenIds(conditionId, tokenIds, amount) {
        return this.ctfClient.canMergeWithTokenIds(conditionId, tokenIds, amount);
    }
    /**
     * Check if wallet has sufficient USDC for split
     */
    async canSplit(amount) {
        return this.ctfClient.canSplit(amount);
    }
    // ===== Market Resolution =====
    /**
     * Check if a market is resolved and get payout info
     */
    async getMarketResolution(conditionId) {
        return this.ctfClient.getMarketResolution(conditionId);
    }
    // ===== Gas Estimation =====
    /**
     * Get detailed gas estimate for a split operation
     */
    async estimateSplitGas(conditionId, amount) {
        return this.ctfClient.getDetailedSplitGasEstimate(conditionId, amount);
    }
    /**
     * Get detailed gas estimate for a merge operation
     */
    async estimateMergeGas(conditionId, amount) {
        return this.ctfClient.getDetailedMergeGasEstimate(conditionId, amount);
    }
    /**
     * Get current gas price info
     */
    async getGasPrice() {
        return this.ctfClient.getGasPrice();
    }
    // ===== Transaction Monitoring =====
    /**
     * Get transaction status with detailed info
     */
    async getTransactionStatus(txHash) {
        return this.ctfClient.getTransactionStatus(txHash);
    }
    /**
     * Wait for transaction confirmation with timeout
     */
    async waitForTransaction(txHash, confirmations) {
        return this.ctfClient.waitForTransaction(txHash, confirmations);
    }
    // ===== Swaps =====
    /**
     * Get a quote for a swap (checks if route is possible)
     */
    async getSwapQuote(tokenIn, tokenOut, amount) {
        return this.swapService.getQuote(tokenIn, tokenOut, amount);
    }
    /**
     * Execute a token swap using QuickSwap V3
     *
     * @param tokenIn - Token to swap from (e.g., 'MATIC', 'USDC', 'USDT')
     * @param tokenOut - Token to swap to (e.g., 'USDC_E', 'WETH')
     * @param amount - Amount to swap in token units
     * @param slippage - Slippage tolerance in percent (default: 0.5)
     */
    async swap(tokenIn, tokenOut, amount, slippage) {
        return this.swapService.swap(tokenIn, tokenOut, amount, { slippage });
    }
    /**
     * Swap any supported token to USDC.e and deposit to Polymarket
     *
     * This is a convenience method for converting tokens to the USDC.e
     * format required by Polymarket CTF operations.
     */
    async swapAndDeposit(token, amount, slippage) {
        return this.swapService.swapToUsdc(token, amount, {
            usdcType: 'USDC_E',
            slippage,
        });
    }
    /**
     * Get all available liquidity pools on QuickSwap V3
     */
    async getAvailablePools() {
        return this.swapService.getAvailablePools();
    }
    /**
     * Check if a pool exists for a token pair
     */
    async checkPool(tokenA, tokenB) {
        return this.swapService.checkPool(tokenA, tokenB);
    }
    // ===== Token Transfers =====
    /**
     * Transfer an ERC20 token to another address
     */
    async transfer(token, to, amount) {
        return this.swapService.transfer(token, to, amount);
    }
    /**
     * Transfer native MATIC to another address
     */
    async transferMatic(to, amount) {
        return this.swapService.transferMatic(to, amount);
    }
    /**
     * Transfer native USDC to another address
     *
     * WARNING: This transfers NATIVE USDC, not USDC.e.
     * For Polymarket CTF operations, use transferUsdcE() instead.
     */
    async transferUsdc(to, amount) {
        return this.swapService.transferUsdc(to, amount);
    }
    /**
     * Transfer USDC.e (bridged USDC) to another address
     *
     * This is the correct method for Polymarket CTF operations.
     */
    async transferUsdcE(to, amount) {
        return this.swapService.transferUsdcE(to, amount);
    }
    // ===== MATIC Wrapping =====
    /**
     * Wrap native MATIC to WMATIC
     */
    async wrapMatic(amount) {
        return this.swapService.wrapMatic(amount);
    }
    /**
     * Unwrap WMATIC to native MATIC
     */
    async unwrapMatic(amount) {
        return this.swapService.unwrapMatic(amount);
    }
    // ===== Advanced Access =====
    /**
     * Get the underlying CTFClient for advanced operations
     */
    getCTFClient() {
        return this.ctfClient;
    }
    /**
     * Get the underlying AuthorizationService for advanced operations
     */
    getAuthorizationService() {
        return this.authService;
    }
    /**
     * Get the underlying SwapService for advanced operations
     */
    getSwapService() {
        return this.swapService;
    }
    /**
     * Get the shared wallet instance
     */
    getWallet() {
        return this.wallet;
    }
    /**
     * Get the shared provider instance
     */
    getProvider() {
        return this.provider;
    }
}
//# sourceMappingURL=onchain-service.js.map