/**
 * @catalyst-team/poly-sdk
 *
 * Unified SDK for Polymarket APIs
 * - Data API (positions, activity, trades, leaderboard)
 * - Gamma API (markets, events, trending)
 * - CLOB API (orderbook, market info, trading)
 * - Services (WalletService, MarketService)
 */
// Core infrastructure
export { RateLimiter, ApiType } from './core/rate-limiter.js';
export { Cache, CACHE_TTL } from './core/cache.js';
export { PolymarketError, ErrorCode, withRetry } from './core/errors.js';
export * from './core/types.js';
export { createUnifiedCache } from './core/unified-cache.js';
// API Clients
export { DataApiClient } from './clients/data-api.js';
export { GammaApiClient } from './clients/gamma-api.js';
// ClobApiClient has been removed - use TradingService instead
// TradingService provides getMarket(), getProcessedOrderbook(), etc.
// Subgraph Client (on-chain data via Goldsky)
export { SubgraphClient, SUBGRAPH_ENDPOINTS } from './clients/subgraph.js';
// Services
export { WalletService } from './services/wallet-service.js';
export { MarketService, getIntervalMs as getIntervalMsService } from './services/market-service.js';
// Real-time (V2 - using official @polymarket/real-time-data-client)
export { RealtimeServiceV2 } from './services/realtime-service-v2.js';
// RealtimeService (legacy) has been removed - use RealtimeServiceV2 instead
// ArbitrageService (Real-time arbitrage detection, execution, rebalancing, and settlement)
export { ArbitrageService } from './services/arbitrage-service.js';
// SmartMoneyService - Smart Money detection and Copy Trading
export { SmartMoneyService } from './services/smart-money-service.js';
// TradingService - Unified trading and market data
export { TradingService, POLYGON_MAINNET, POLYGON_AMOY } from './services/trading-service.js';
// TradingClient (legacy) has been removed - use TradingService instead
// TradingService provides all trading functionality with proper type exports
// CTF (Conditional Token Framework)
// NOTE: USDC_CONTRACT is USDC.e (bridged), required for Polymarket CTF
// NATIVE_USDC_CONTRACT is native USDC, NOT compatible with CTF
export { CTFClient, CTF_CONTRACT, USDC_CONTRACT, // USDC.e (0x2791...) - Required for CTF
NATIVE_USDC_CONTRACT, // Native USDC (0x3c49...) - NOT for CTF
NEG_RISK_CTF_EXCHANGE, NEG_RISK_ADAPTER, USDC_DECIMALS, calculateConditionId, parseUsdc, formatUsdc, } from './clients/ctf-client.js';
export { RevertReason } from './clients/ctf-client.js';
// Bridge (Cross-chain Deposits)
export { BridgeClient, SUPPORTED_CHAINS, BRIDGE_TOKENS, estimateBridgeOutput, getExplorerUrl, depositUsdc, swapAndDeposit, getSupportedDepositTokens, } from './clients/bridge-client.js';
// Swap Service (DEX swaps on Polygon)
export { SwapService, QUICKSWAP_ROUTER, POLYGON_TOKENS, TOKEN_DECIMALS, } from './services/swap-service.js';
// Authorization (ERC20/ERC1155 Approvals)
export { AuthorizationService } from './services/authorization-service.js';
// OnchainService (Unified on-chain operations: CTF + Authorization + Swaps)
export { OnchainService } from './services/onchain-service.js';
// Price Utilities
export { roundPrice, roundSize, validatePrice, validateSize, calculateBuyAmount, calculateSellPayout, calculateSharesForAmount, calculateSpread, calculateMidpoint, formatPrice, formatUSDC, calculatePnL, checkArbitrage, getEffectivePrices, ROUNDING_CONFIG, } from './utils/price-utils.js';
// NOTE: MCP tools have been moved to @catalyst-team/poly-mcp package
// See packages/poly-mcp/
// ===== Main SDK Class =====
import { RateLimiter } from './core/rate-limiter.js';
import { DataApiClient } from './clients/data-api.js';
import { GammaApiClient } from './clients/gamma-api.js';
import { SubgraphClient } from './clients/subgraph.js';
import { WalletService } from './services/wallet-service.js';
import { MarketService } from './services/market-service.js';
import { TradingService } from './services/trading-service.js';
import { RealtimeServiceV2 } from './services/realtime-service-v2.js';
import { SmartMoneyService } from './services/smart-money-service.js';
import { createUnifiedCache } from './core/unified-cache.js';
export class PolymarketSDK {
    // Infrastructure
    rateLimiter;
    cache;
    // API Clients
    dataApi;
    gammaApi;
    tradingService;
    subgraph;
    // Services
    wallets;
    markets;
    realtime;
    smartMoney;
    // Initialization state
    _initialized = false;
    constructor(config = {}) {
        // Initialize infrastructure
        this.rateLimiter = new RateLimiter();
        // Create unified cache (supports both legacy Cache and CacheAdapter)
        this.cache = createUnifiedCache(config.cache);
        // Initialize API clients
        this.dataApi = new DataApiClient(this.rateLimiter, this.cache);
        this.gammaApi = new GammaApiClient(this.rateLimiter, this.cache);
        // TradingService requires a private key - use provided key or dummy key for read-only
        const privateKey = config.privateKey || '0x' + '1'.repeat(64);
        this.tradingService = new TradingService(this.rateLimiter, this.cache, {
            privateKey,
            chainId: config.chainId,
            credentials: config.creds,
        });
        this.subgraph = new SubgraphClient(this.rateLimiter, this.cache);
        // Initialize services
        this.wallets = new WalletService(this.dataApi, this.subgraph, this.cache);
        this.markets = new MarketService(this.gammaApi, this.dataApi, this.rateLimiter, this.cache);
        this.realtime = new RealtimeServiceV2();
        this.smartMoney = new SmartMoneyService(this.wallets, this.realtime, this.tradingService);
    }
    // ===== Static Factory Methods =====
    /**
     * Create and initialize SDK in one call
     *
     * @example
     * ```typescript
     * const sdk = await PolymarketSDK.create({ privateKey: '...' });
     * // Ready to trade and track smart money
     * ```
     */
    static async create(config = {}) {
        const sdk = new PolymarketSDK(config);
        await sdk.start();
        return sdk;
    }
    // ===== Lifecycle Methods =====
    /**
     * Initialize the SDK (required for trading operations)
     */
    async initialize() {
        if (this._initialized)
            return;
        await this.tradingService.initialize();
        this._initialized = true;
    }
    /**
     * Check if SDK is initialized
     */
    isInitialized() {
        return this._initialized;
    }
    /**
     * Start SDK - initialize trading + connect WebSocket
     *
     * One method to do everything:
     * - Initialize trading service (derive API credentials)
     * - Connect WebSocket
     * - Wait for connection
     *
     * @example
     * ```typescript
     * const sdk = new PolymarketSDK({ privateKey: '...' });
     * await sdk.start();
     * // Ready to use
     * ```
     */
    async start(options = {}) {
        await this.initialize();
        this.connect();
        await this.waitForConnection(options.timeout ?? 10000);
    }
    /**
     * Connect to realtime WebSocket (required for smart money tracking)
     */
    connect() {
        this.realtime.connect();
    }
    /**
     * Wait for WebSocket connection
     */
    async waitForConnection(timeoutMs = 10000) {
        // Already connected
        if (this.realtime.isConnected?.()) {
            return;
        }
        return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => reject(new Error('Connection timeout')), timeoutMs);
            this.realtime.once('connected', () => {
                clearTimeout(timeout);
                resolve();
            });
        });
    }
    /**
     * Stop SDK - disconnect all services and clean up
     */
    stop() {
        this.smartMoney.disconnect();
        this.realtime.disconnect();
    }
    /**
     * Disconnect all services and clean up
     * @deprecated Use stop() instead
     */
    disconnect() {
        this.stop();
    }
    // ===== Unified Market Access =====
    /**
     * Get market by slug or condition ID
     * Delegates to MarketService which handles merging Gamma and CLOB data
     */
    async getMarket(identifier) {
        return this.markets.getMarket(identifier);
    }
    // ===== Orderbook Analysis =====
    /**
     * Get processed orderbook with analytics
     */
    async getOrderbook(conditionId) {
        return this.markets.getProcessedOrderbook(conditionId);
    }
    /**
     * Detect arbitrage opportunity
     *
     * 使用有效价格计算套利机会（正确考虑镜像订单）
     * 详细文档见: docs/01-polymarket-orderbook-arbitrage.md
     */
    async detectArbitrage(conditionId, threshold = 0.005) {
        const orderbook = await this.getOrderbook(conditionId);
        const { effectivePrices, longArbProfit, shortArbProfit } = orderbook.summary;
        if (longArbProfit > threshold) {
            return {
                type: 'long',
                profit: longArbProfit,
                action: `Buy YES @ ${effectivePrices.effectiveBuyYes.toFixed(4)} + Buy NO @ ${effectivePrices.effectiveBuyNo.toFixed(4)}, merge for 1 USDC`,
                expectedProfit: longArbProfit,
            };
        }
        if (shortArbProfit > threshold) {
            return {
                type: 'short',
                profit: shortArbProfit,
                action: `Split 1 USDC, Sell YES @ ${effectivePrices.effectiveSellYes.toFixed(4)} + Sell NO @ ${effectivePrices.effectiveSellNo.toFixed(4)}`,
                expectedProfit: shortArbProfit,
            };
        }
        return null;
    }
    // ===== Cache Management =====
    /**
     * Clear all cached data
     */
    clearCache() {
        this.cache.clear();
    }
    /**
     * Invalidate cache for a specific market
     */
    invalidateMarketCache(conditionId) {
        this.cache.invalidate(conditionId);
    }
}
//# sourceMappingURL=index.js.map