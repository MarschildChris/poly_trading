/**
 * Bridge adapter between legacy Cache class and new CacheAdapter interface
 *
 * This allows the SDK to work with both:
 * 1. Legacy internal Cache (synchronous, millisecond TTL)
 * 2. New CacheAdapter interface (async, second TTL)
 */
/**
 * Wraps the legacy Cache class to implement CacheAdapter interface
 */
export class LegacyCacheAdapter {
    cache;
    constructor(cache) {
        this.cache = cache;
    }
    async get(key) {
        const value = this.cache.get(key);
        return value === undefined ? null : value;
    }
    async set(key, value, ttl) {
        // Convert seconds to milliseconds (CacheAdapter uses seconds, Cache uses ms)
        const ttlMs = ttl ? ttl * 1000 : 60000; // Default 60s
        this.cache.set(key, value, ttlMs);
    }
    async del(key) {
        this.cache.invalidate(key);
    }
    async exists(key) {
        const value = this.cache.get(key);
        return value !== undefined;
    }
    async clear() {
        this.cache.clear();
    }
}
/**
 * Wraps a CacheAdapter to provide the legacy Cache interface
 * This allows using new cache adapters with code expecting the old Cache class
 */
export class CacheAdapterWrapper {
    adapter;
    constructor(adapter) {
        this.adapter = adapter;
    }
    get(key) {
        // Note: This makes an async operation sync, which may cause issues
        // However, we need to maintain backward compatibility
        let result;
        this.adapter.get(key).then((value) => {
            result = value ?? undefined;
        });
        return result;
    }
    set(key, value, ttlMs) {
        // Convert milliseconds to seconds
        const ttlSeconds = Math.ceil(ttlMs / 1000);
        void this.adapter.set(key, value, ttlSeconds);
    }
    async getOrSet(key, ttlMs, factory) {
        const cached = await this.adapter.get(key);
        if (cached !== null)
            return cached;
        const value = await factory();
        const ttlSeconds = Math.ceil(ttlMs / 1000);
        await this.adapter.set(key, value, ttlSeconds);
        return value;
    }
    invalidate(pattern) {
        // CacheAdapter doesn't have pattern matching, so we can't implement this
        // This is a limitation of the adapter approach
        console.warn('invalidate(pattern) not supported with external cache adapter');
    }
    clear() {
        void this.adapter.clear?.();
    }
    size() {
        // CacheAdapter doesn't expose size, return -1 to indicate unknown
        return -1;
    }
}
//# sourceMappingURL=cache-adapter-bridge.js.map