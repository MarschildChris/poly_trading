/**
 * Bridge adapter between legacy Cache class and new CacheAdapter interface
 *
 * This allows the SDK to work with both:
 * 1. Legacy internal Cache (synchronous, millisecond TTL)
 * 2. New CacheAdapter interface (async, second TTL)
 */
import type { CacheAdapter } from '@catalyst-team/cache';
import { Cache } from './cache.js';
/**
 * Wraps the legacy Cache class to implement CacheAdapter interface
 */
export declare class LegacyCacheAdapter implements CacheAdapter {
    private cache;
    constructor(cache: Cache);
    get<T>(key: string): Promise<T | null>;
    set<T>(key: string, value: T, ttl?: number): Promise<void>;
    del(key: string): Promise<void>;
    exists(key: string): Promise<boolean>;
    clear(): Promise<void>;
}
/**
 * Wraps a CacheAdapter to provide the legacy Cache interface
 * This allows using new cache adapters with code expecting the old Cache class
 */
export declare class CacheAdapterWrapper {
    private adapter;
    constructor(adapter: CacheAdapter);
    get<T>(key: string): T | undefined;
    set<T>(key: string, value: T, ttlMs: number): void;
    getOrSet<T>(key: string, ttlMs: number, factory: () => Promise<T>): Promise<T>;
    invalidate(pattern: string): void;
    clear(): void;
    size(): number;
}
//# sourceMappingURL=cache-adapter-bridge.d.ts.map