/**
 * RealtimeService V2
 *
 * Comprehensive real-time data service using official @polymarket/real-time-data-client.
 *
 * Supports ALL available topics:
 * - clob_market: price_change, agg_orderbook, last_trade_price, tick_size_change, market_created, market_resolved
 * - clob_user: order, trade (requires authentication)
 * - activity: trades, orders_matched
 * - crypto_prices: update (BTC, ETH, etc.)
 * - equity_prices: update (AAPL, etc.)
 * - comments: comment_created, comment_removed, reaction_created, reaction_removed
 * - rfq: request_*, quote_*
 */
import { EventEmitter } from 'events';
import { RealTimeDataClient, ConnectionStatus, } from '@polymarket/real-time-data-client';
// ============================================================================
// RealtimeServiceV2 Implementation
// ============================================================================
export class RealtimeServiceV2 extends EventEmitter {
    client = null;
    config;
    subscriptions = new Map();
    subscriptionIdCounter = 0;
    connected = false;
    // Caches
    priceCache = new Map();
    bookCache = new Map();
    lastTradeCache = new Map();
    constructor(config = {}) {
        super();
        this.config = {
            autoReconnect: config.autoReconnect ?? true,
            pingInterval: config.pingInterval ?? 5000,
            debug: config.debug ?? false,
        };
    }
    // ============================================================================
    // Connection Management
    // ============================================================================
    /**
     * Connect to WebSocket server
     */
    connect() {
        if (this.client) {
            this.log('Already connected or connecting');
            return this;
        }
        this.client = new RealTimeDataClient({
            onConnect: this.handleConnect.bind(this),
            onMessage: this.handleMessage.bind(this),
            onStatusChange: this.handleStatusChange.bind(this),
            autoReconnect: this.config.autoReconnect,
            pingInterval: this.config.pingInterval,
        });
        this.client.connect();
        return this;
    }
    /**
     * Disconnect from WebSocket server
     */
    disconnect() {
        if (this.client) {
            this.client.disconnect();
            this.client = null;
            this.connected = false;
            this.subscriptions.clear();
        }
    }
    /**
     * Check if connected
     */
    isConnected() {
        return this.connected;
    }
    // ============================================================================
    // Market Data Subscriptions (clob_market)
    // ============================================================================
    /**
     * Subscribe to market data (orderbook, prices, trades)
     * @param tokenIds - Array of token IDs to subscribe to
     * @param handlers - Event handlers
     */
    subscribeMarkets(tokenIds, handlers = {}) {
        const subId = `market_${++this.subscriptionIdCounter}`;
        const filterStr = JSON.stringify(tokenIds);
        // Subscribe to all market data types
        const subscriptions = [
            { topic: 'clob_market', type: 'agg_orderbook', filters: filterStr },
            { topic: 'clob_market', type: 'price_change', filters: filterStr },
            { topic: 'clob_market', type: 'last_trade_price', filters: filterStr },
            { topic: 'clob_market', type: 'tick_size_change', filters: filterStr },
        ];
        this.sendSubscription({ subscriptions });
        // Register handlers
        const orderbookHandler = (book) => {
            if (tokenIds.includes(book.assetId)) {
                handlers.onOrderbook?.(book);
            }
        };
        const priceChangeHandler = (change) => {
            if (tokenIds.includes(change.assetId)) {
                handlers.onPriceChange?.(change);
            }
        };
        const lastTradeHandler = (trade) => {
            if (tokenIds.includes(trade.assetId)) {
                handlers.onLastTrade?.(trade);
            }
        };
        const tickSizeHandler = (change) => {
            if (tokenIds.includes(change.assetId)) {
                handlers.onTickSizeChange?.(change);
            }
        };
        this.on('orderbook', orderbookHandler);
        this.on('priceChange', priceChangeHandler);
        this.on('lastTrade', lastTradeHandler);
        this.on('tickSizeChange', tickSizeHandler);
        const subscription = {
            id: subId,
            topic: 'clob_market',
            type: '*',
            tokenIds,
            unsubscribe: () => {
                this.off('orderbook', orderbookHandler);
                this.off('priceChange', priceChangeHandler);
                this.off('lastTrade', lastTradeHandler);
                this.off('tickSizeChange', tickSizeHandler);
                this.sendUnsubscription({ subscriptions });
                this.subscriptions.delete(subId);
            },
        };
        this.subscriptions.set(subId, subscription);
        return subscription;
    }
    /**
     * Subscribe to a single market (YES + NO tokens)
     * Also emits derived price updates compatible with old API
     */
    subscribeMarket(yesTokenId, noTokenId, handlers = {}) {
        let lastYesUpdate;
        let lastNoUpdate;
        const checkPairUpdate = () => {
            if (lastYesUpdate && lastNoUpdate && handlers.onPairUpdate) {
                handlers.onPairUpdate({
                    yes: lastYesUpdate,
                    no: lastNoUpdate,
                    spread: lastYesUpdate.price + lastNoUpdate.price,
                });
            }
        };
        return this.subscribeMarkets([yesTokenId, noTokenId], {
            onOrderbook: (book) => {
                handlers.onOrderbook?.(book);
                // Convert to BookUpdate for backward compatibility
                if (handlers.onBookUpdate) {
                    const bookUpdate = {
                        assetId: book.assetId,
                        bids: book.bids,
                        asks: book.asks,
                        timestamp: book.timestamp,
                    };
                    handlers.onBookUpdate(bookUpdate);
                }
                // Calculate derived price (Polymarket display logic)
                const priceUpdate = this.calculateDerivedPrice(book.assetId, book);
                if (priceUpdate) {
                    this.priceCache.set(book.assetId, priceUpdate);
                    if (book.assetId === yesTokenId) {
                        lastYesUpdate = priceUpdate;
                    }
                    else if (book.assetId === noTokenId) {
                        lastNoUpdate = priceUpdate;
                    }
                    handlers.onPriceUpdate?.(priceUpdate);
                    this.emit('priceUpdate', priceUpdate);
                    checkPairUpdate();
                }
            },
            onLastTrade: (trade) => {
                handlers.onLastTrade?.(trade);
                this.lastTradeCache.set(trade.assetId, trade);
                // Recalculate derived price with new last trade
                const book = this.bookCache.get(trade.assetId);
                if (book) {
                    const priceUpdate = this.calculateDerivedPrice(trade.assetId, book);
                    if (priceUpdate) {
                        this.priceCache.set(trade.assetId, priceUpdate);
                        if (trade.assetId === yesTokenId) {
                            lastYesUpdate = priceUpdate;
                        }
                        else if (trade.assetId === noTokenId) {
                            lastNoUpdate = priceUpdate;
                        }
                        handlers.onPriceUpdate?.(priceUpdate);
                        this.emit('priceUpdate', priceUpdate);
                        checkPairUpdate();
                    }
                }
            },
            onPriceChange: handlers.onPriceChange,
            onTickSizeChange: handlers.onTickSizeChange,
            onError: handlers.onError,
        });
    }
    /**
     * Subscribe to market lifecycle events (creation, resolution)
     */
    subscribeMarketEvents(handlers) {
        const subId = `market_event_${++this.subscriptionIdCounter}`;
        const subscriptions = [
            { topic: 'clob_market', type: 'market_created' },
            { topic: 'clob_market', type: 'market_resolved' },
        ];
        this.sendSubscription({ subscriptions });
        const handler = (event) => handlers.onMarketEvent?.(event);
        this.on('marketEvent', handler);
        const subscription = {
            id: subId,
            topic: 'clob_market',
            type: 'lifecycle',
            unsubscribe: () => {
                this.off('marketEvent', handler);
                this.sendUnsubscription({ subscriptions });
                this.subscriptions.delete(subId);
            },
        };
        this.subscriptions.set(subId, subscription);
        return subscription;
    }
    // ============================================================================
    // User Data Subscriptions (clob_user) - Requires Authentication
    // ============================================================================
    /**
     * Subscribe to user order and trade events
     * @param credentials - CLOB API credentials
     * @param handlers - Event handlers
     */
    subscribeUserEvents(credentials, handlers = {}) {
        const subId = `user_${++this.subscriptionIdCounter}`;
        const subscriptions = [
            { topic: 'clob_user', type: '*', clob_auth: credentials },
        ];
        this.sendSubscription({ subscriptions });
        const orderHandler = (order) => handlers.onOrder?.(order);
        const tradeHandler = (trade) => handlers.onTrade?.(trade);
        this.on('userOrder', orderHandler);
        this.on('userTrade', tradeHandler);
        const subscription = {
            id: subId,
            topic: 'clob_user',
            type: '*',
            unsubscribe: () => {
                this.off('userOrder', orderHandler);
                this.off('userTrade', tradeHandler);
                this.sendUnsubscription({ subscriptions });
                this.subscriptions.delete(subId);
            },
        };
        this.subscriptions.set(subId, subscription);
        return subscription;
    }
    // ============================================================================
    // Activity Subscriptions (trades, orders_matched)
    // ============================================================================
    /**
     * Subscribe to trading activity for a market or event
     * @param filter - Event or market slug (optional - if empty, subscribes to all activity)
     * @param handlers - Event handlers
     */
    subscribeActivity(filter = {}, handlers = {}) {
        const subId = `activity_${++this.subscriptionIdCounter}`;
        // Build filter object with snake_case keys (as expected by the server)
        // Only include filters if we have actual filter values
        const hasFilter = filter.eventSlug || filter.marketSlug;
        const filterObj = {};
        if (filter.eventSlug)
            filterObj.event_slug = filter.eventSlug;
        if (filter.marketSlug)
            filterObj.market_slug = filter.marketSlug;
        // Create subscription objects - only include filters field if we have filters
        const subscriptions = hasFilter
            ? [
                { topic: 'activity', type: 'trades', filters: JSON.stringify(filterObj) },
                { topic: 'activity', type: 'orders_matched', filters: JSON.stringify(filterObj) },
            ]
            : [
                { topic: 'activity', type: 'trades' },
                { topic: 'activity', type: 'orders_matched' },
            ];
        this.sendSubscription({ subscriptions });
        const handler = (trade) => handlers.onTrade?.(trade);
        this.on('activityTrade', handler);
        const subscription = {
            id: subId,
            topic: 'activity',
            type: '*',
            unsubscribe: () => {
                this.off('activityTrade', handler);
                this.sendUnsubscription({ subscriptions });
                this.subscriptions.delete(subId);
            },
        };
        this.subscriptions.set(subId, subscription);
        return subscription;
    }
    /**
     * Subscribe to ALL trading activity across all markets (no filtering)
     * This is useful for Copy Trading - monitoring Smart Money across the platform
     * @param handlers - Event handlers
     */
    subscribeAllActivity(handlers = {}) {
        return this.subscribeActivity({}, handlers);
    }
    // ============================================================================
    // Crypto Price Subscriptions
    // ============================================================================
    /**
     * Subscribe to crypto price updates
     * @param symbols - Array of symbols (e.g., ['BTCUSDT', 'ETHUSDT'])
     * @param handlers - Event handlers
     */
    subscribeCryptoPrices(symbols, handlers = {}) {
        const subId = `crypto_${++this.subscriptionIdCounter}`;
        // Subscribe to each symbol
        const subscriptions = symbols.map(symbol => ({
            topic: 'crypto_prices',
            type: 'update',
            filters: JSON.stringify({ symbol }),
        }));
        this.sendSubscription({ subscriptions });
        const handler = (price) => {
            if (symbols.includes(price.symbol)) {
                handlers.onPrice?.(price);
            }
        };
        this.on('cryptoPrice', handler);
        const subscription = {
            id: subId,
            topic: 'crypto_prices',
            type: 'update',
            unsubscribe: () => {
                this.off('cryptoPrice', handler);
                this.sendUnsubscription({ subscriptions });
                this.subscriptions.delete(subId);
            },
        };
        this.subscriptions.set(subId, subscription);
        return subscription;
    }
    /**
     * Subscribe to Chainlink crypto prices
     * @param symbols - Array of symbols (e.g., ['ETH/USD', 'BTC/USD'])
     */
    subscribeCryptoChainlinkPrices(symbols, handlers = {}) {
        const subId = `crypto_chainlink_${++this.subscriptionIdCounter}`;
        const subscriptions = symbols.map(symbol => ({
            topic: 'crypto_prices_chainlink',
            type: 'update',
            filters: JSON.stringify({ symbol }),
        }));
        this.sendSubscription({ subscriptions });
        const handler = (price) => {
            if (symbols.includes(price.symbol)) {
                handlers.onPrice?.(price);
            }
        };
        this.on('cryptoChainlinkPrice', handler);
        const subscription = {
            id: subId,
            topic: 'crypto_prices_chainlink',
            type: 'update',
            unsubscribe: () => {
                this.off('cryptoChainlinkPrice', handler);
                this.sendUnsubscription({ subscriptions });
                this.subscriptions.delete(subId);
            },
        };
        this.subscriptions.set(subId, subscription);
        return subscription;
    }
    // ============================================================================
    // Equity Price Subscriptions
    // ============================================================================
    /**
     * Subscribe to equity price updates
     * @param symbols - Array of symbols (e.g., ['AAPL', 'GOOGL'])
     * @param handlers - Event handlers
     */
    subscribeEquityPrices(symbols, handlers = {}) {
        const subId = `equity_${++this.subscriptionIdCounter}`;
        const subscriptions = symbols.map(symbol => ({
            topic: 'equity_prices',
            type: 'update',
            filters: JSON.stringify({ symbol }),
        }));
        this.sendSubscription({ subscriptions });
        const handler = (price) => {
            if (symbols.includes(price.symbol)) {
                handlers.onPrice?.(price);
            }
        };
        this.on('equityPrice', handler);
        const subscription = {
            id: subId,
            topic: 'equity_prices',
            type: 'update',
            unsubscribe: () => {
                this.off('equityPrice', handler);
                this.sendUnsubscription({ subscriptions });
                this.subscriptions.delete(subId);
            },
        };
        this.subscriptions.set(subId, subscription);
        return subscription;
    }
    // ============================================================================
    // Comments Subscriptions
    // ============================================================================
    /**
     * Subscribe to comment and reaction events
     */
    subscribeComments(filter, handlers = {}) {
        const subId = `comments_${++this.subscriptionIdCounter}`;
        const filterStr = JSON.stringify({
            parentEntityID: filter.parentEntityId,
            parentEntityType: filter.parentEntityType,
        });
        const subscriptions = [
            { topic: 'comments', type: 'comment_created', filters: filterStr },
            { topic: 'comments', type: 'comment_removed', filters: filterStr },
            { topic: 'comments', type: 'reaction_created', filters: filterStr },
            { topic: 'comments', type: 'reaction_removed', filters: filterStr },
        ];
        this.sendSubscription({ subscriptions });
        const commentHandler = (comment) => handlers.onComment?.(comment);
        const reactionHandler = (reaction) => handlers.onReaction?.(reaction);
        this.on('comment', commentHandler);
        this.on('reaction', reactionHandler);
        const subscription = {
            id: subId,
            topic: 'comments',
            type: '*',
            unsubscribe: () => {
                this.off('comment', commentHandler);
                this.off('reaction', reactionHandler);
                this.sendUnsubscription({ subscriptions });
                this.subscriptions.delete(subId);
            },
        };
        this.subscriptions.set(subId, subscription);
        return subscription;
    }
    // ============================================================================
    // RFQ Subscriptions
    // ============================================================================
    /**
     * Subscribe to RFQ (Request for Quote) events
     */
    subscribeRFQ(handlers = {}) {
        const subId = `rfq_${++this.subscriptionIdCounter}`;
        const subscriptions = [
            { topic: 'rfq', type: 'request_created' },
            { topic: 'rfq', type: 'request_edited' },
            { topic: 'rfq', type: 'request_canceled' },
            { topic: 'rfq', type: 'request_expired' },
            { topic: 'rfq', type: 'quote_created' },
            { topic: 'rfq', type: 'quote_edited' },
            { topic: 'rfq', type: 'quote_canceled' },
            { topic: 'rfq', type: 'quote_expired' },
        ];
        this.sendSubscription({ subscriptions });
        const requestHandler = (request) => handlers.onRequest?.(request);
        const quoteHandler = (quote) => handlers.onQuote?.(quote);
        this.on('rfqRequest', requestHandler);
        this.on('rfqQuote', quoteHandler);
        const subscription = {
            id: subId,
            topic: 'rfq',
            type: '*',
            unsubscribe: () => {
                this.off('rfqRequest', requestHandler);
                this.off('rfqQuote', quoteHandler);
                this.sendUnsubscription({ subscriptions });
                this.subscriptions.delete(subId);
            },
        };
        this.subscriptions.set(subId, subscription);
        return subscription;
    }
    // ============================================================================
    // Cache Access
    // ============================================================================
    /**
     * Get cached derived price for an asset
     */
    getPrice(assetId) {
        return this.priceCache.get(assetId);
    }
    /**
     * Get all cached prices
     */
    getAllPrices() {
        return new Map(this.priceCache);
    }
    /**
     * Get cached orderbook for an asset
     */
    getBook(assetId) {
        return this.bookCache.get(assetId);
    }
    /**
     * Get cached last trade for an asset
     */
    getLastTrade(assetId) {
        return this.lastTradeCache.get(assetId);
    }
    // ============================================================================
    // Subscription Management
    // ============================================================================
    /**
     * Get all active subscriptions
     */
    getActiveSubscriptions() {
        return Array.from(this.subscriptions.values());
    }
    /**
     * Unsubscribe from all
     */
    unsubscribeAll() {
        for (const sub of this.subscriptions.values()) {
            sub.unsubscribe();
        }
        this.subscriptions.clear();
    }
    // ============================================================================
    // Private Methods
    // ============================================================================
    handleConnect(client) {
        this.connected = true;
        this.log('Connected to WebSocket server');
        this.emit('connected');
    }
    handleStatusChange(status) {
        this.log(`Connection status: ${status}`);
        if (status === ConnectionStatus.DISCONNECTED) {
            this.connected = false;
            this.emit('disconnected');
        }
        else if (status === ConnectionStatus.CONNECTED) {
            this.connected = true;
        }
        this.emit('statusChange', status);
    }
    handleMessage(client, message) {
        this.log(`Received: ${message.topic}:${message.type}`);
        const payload = message.payload;
        switch (message.topic) {
            case 'clob_market':
                this.handleMarketMessage(message.type, payload, message.timestamp);
                break;
            case 'clob_user':
                this.handleUserMessage(message.type, payload, message.timestamp);
                break;
            case 'activity':
                this.handleActivityMessage(message.type, payload, message.timestamp);
                break;
            case 'crypto_prices':
                this.handleCryptoPriceMessage(payload, message.timestamp);
                break;
            case 'crypto_prices_chainlink':
                this.handleCryptoChainlinkPriceMessage(payload, message.timestamp);
                break;
            case 'equity_prices':
                this.handleEquityPriceMessage(payload, message.timestamp);
                break;
            case 'comments':
                this.handleCommentMessage(message.type, payload, message.timestamp);
                break;
            case 'rfq':
                this.handleRFQMessage(message.type, payload, message.timestamp);
                break;
            default:
                this.log(`Unknown topic: ${message.topic}`);
        }
    }
    handleMarketMessage(type, payload, timestamp) {
        switch (type) {
            case 'agg_orderbook': {
                const book = this.parseOrderbook(payload, timestamp);
                this.bookCache.set(book.assetId, book);
                this.emit('orderbook', book);
                break;
            }
            case 'price_change': {
                const change = this.parsePriceChange(payload, timestamp);
                this.emit('priceChange', change);
                break;
            }
            case 'last_trade_price': {
                const trade = this.parseLastTrade(payload, timestamp);
                this.lastTradeCache.set(trade.assetId, trade);
                this.emit('lastTrade', trade);
                break;
            }
            case 'tick_size_change': {
                const change = this.parseTickSizeChange(payload, timestamp);
                this.emit('tickSizeChange', change);
                break;
            }
            case 'market_created':
            case 'market_resolved': {
                const event = {
                    conditionId: payload.condition_id || '',
                    type: type === 'market_created' ? 'created' : 'resolved',
                    data: payload,
                    timestamp,
                };
                this.emit('marketEvent', event);
                break;
            }
        }
    }
    handleUserMessage(type, payload, timestamp) {
        if (type === 'order') {
            const order = {
                orderId: payload.order_id || '',
                market: payload.market || '',
                asset: payload.asset || '',
                side: payload.side,
                price: Number(payload.price) || 0,
                originalSize: Number(payload.original_size) || 0,
                matchedSize: Number(payload.matched_size) || 0,
                eventType: payload.event_type,
                timestamp,
            };
            this.emit('userOrder', order);
        }
        else if (type === 'trade') {
            const trade = {
                tradeId: payload.trade_id || '',
                market: payload.market || '',
                outcome: payload.outcome || '',
                price: Number(payload.price) || 0,
                size: Number(payload.size) || 0,
                side: payload.side,
                status: payload.status,
                timestamp,
                transactionHash: payload.transaction_hash,
            };
            this.emit('userTrade', trade);
        }
    }
    handleActivityMessage(type, payload, timestamp) {
        const trade = {
            asset: payload.asset || '',
            conditionId: payload.conditionId || '',
            eventSlug: payload.eventSlug || '',
            marketSlug: payload.slug || '',
            outcome: payload.outcome || '',
            price: Number(payload.price) || 0,
            side: payload.side,
            size: Number(payload.size) || 0,
            timestamp: Number(payload.timestamp) || timestamp,
            transactionHash: payload.transactionHash || '',
            trader: {
                name: payload.name,
                address: payload.proxyWallet,
            },
        };
        this.emit('activityTrade', trade);
    }
    handleCryptoPriceMessage(payload, timestamp) {
        const price = {
            symbol: payload.symbol || '',
            price: Number(payload.value) || 0,
            timestamp: Number(payload.timestamp) || timestamp,
        };
        this.emit('cryptoPrice', price);
    }
    handleCryptoChainlinkPriceMessage(payload, timestamp) {
        const price = {
            symbol: payload.symbol || '',
            price: Number(payload.value) || 0,
            timestamp: Number(payload.timestamp) || timestamp,
        };
        this.emit('cryptoChainlinkPrice', price);
    }
    handleEquityPriceMessage(payload, timestamp) {
        const price = {
            symbol: payload.symbol || '',
            price: Number(payload.value) || 0,
            timestamp: Number(payload.timestamp) || timestamp,
        };
        this.emit('equityPrice', price);
    }
    handleCommentMessage(type, payload, timestamp) {
        if (type.includes('comment')) {
            const comment = {
                id: payload.id || '',
                parentEntityId: payload.parentEntityID || 0,
                parentEntityType: payload.parentEntityType,
                content: payload.content,
                author: payload.author,
                timestamp,
            };
            this.emit('comment', comment);
        }
        else if (type.includes('reaction')) {
            const reaction = {
                id: payload.id || '',
                commentId: payload.commentId || '',
                type: payload.type || '',
                author: payload.author,
                timestamp,
            };
            this.emit('reaction', reaction);
        }
    }
    handleRFQMessage(type, payload, timestamp) {
        if (type.startsWith('request_')) {
            const status = type.replace('request_', '');
            const request = {
                id: payload.id || '',
                market: payload.market || '',
                side: payload.side,
                size: Number(payload.size) || 0,
                status,
                timestamp,
            };
            this.emit('rfqRequest', request);
        }
        else if (type.startsWith('quote_')) {
            const status = type.replace('quote_', '');
            const quote = {
                id: payload.id || '',
                requestId: payload.request_id || '',
                price: Number(payload.price) || 0,
                size: Number(payload.size) || 0,
                status,
                timestamp,
            };
            this.emit('rfqQuote', quote);
        }
    }
    // Parsers
    parseOrderbook(payload, timestamp) {
        const bidsRaw = payload.bids || [];
        const asksRaw = payload.asks || [];
        // Sort bids descending, asks ascending
        const bids = bidsRaw
            .map(l => ({ price: parseFloat(l.price), size: parseFloat(l.size) }))
            .sort((a, b) => b.price - a.price);
        const asks = asksRaw
            .map(l => ({ price: parseFloat(l.price), size: parseFloat(l.size) }))
            .sort((a, b) => a.price - b.price);
        const tokenId = payload.asset_id || '';
        return {
            tokenId,
            assetId: tokenId, // Backward compatibility
            market: payload.market || '',
            bids,
            asks,
            timestamp: parseInt(payload.timestamp, 10) || timestamp,
            tickSize: payload.tick_size || '0.01',
            minOrderSize: payload.min_order_size || '1',
            hash: payload.hash || '',
        };
    }
    parsePriceChange(payload, timestamp) {
        const changes = payload.price_changes || [];
        return {
            assetId: payload.asset_id || '',
            changes,
            timestamp,
        };
    }
    parseLastTrade(payload, timestamp) {
        return {
            assetId: payload.asset_id || '',
            price: parseFloat(payload.price) || 0,
            side: payload.side || 'BUY',
            size: parseFloat(payload.size) || 0,
            timestamp: parseInt(payload.timestamp, 10) || timestamp,
        };
    }
    parseTickSizeChange(payload, timestamp) {
        return {
            assetId: payload.asset_id || '',
            oldTickSize: payload.old_tick_size || '',
            newTickSize: payload.new_tick_size || '',
            timestamp,
        };
    }
    /**
     * Calculate derived price using Polymarket's display logic:
     * - If spread <= 0.10: use midpoint
     * - If spread > 0.10: use last trade price
     */
    calculateDerivedPrice(assetId, book) {
        if (book.bids.length === 0 || book.asks.length === 0) {
            return null;
        }
        const bestBid = book.bids[0].price;
        const bestAsk = book.asks[0].price;
        const spread = bestAsk - bestBid;
        const midpoint = (bestBid + bestAsk) / 2;
        const lastTrade = this.lastTradeCache.get(assetId);
        const lastTradePrice = lastTrade?.price ?? midpoint;
        // Polymarket display logic
        const displayPrice = spread <= 0.10 ? midpoint : lastTradePrice;
        return {
            assetId,
            price: displayPrice,
            midpoint,
            spread,
            timestamp: book.timestamp,
        };
    }
    sendSubscription(msg) {
        if (this.client && this.connected) {
            this.client.subscribe(msg);
        }
        else {
            this.log('Cannot subscribe: not connected');
        }
    }
    sendUnsubscription(msg) {
        if (this.client && this.connected) {
            this.client.unsubscribe(msg);
        }
    }
    log(message) {
        if (this.config.debug) {
            console.log(`[RealtimeService] ${message}`);
        }
    }
}
//# sourceMappingURL=realtime-service-v2.js.map