/**
 * OnchainService - Unified interface for all on-chain operations
 *
 * Consolidates:
 * - CTF operations (split, merge, redeem)
 * - Authorization (ERC20/ERC1155 approvals)
 * - Swaps (QuickSwap V3)
 *
 * This service provides a single entry point for all blockchain interactions
 * required for Polymarket trading. It shares wallet/provider configuration
 * across all underlying services.
 *
 * @example
 * ```typescript
 * const onchain = new OnchainService({
 *   privateKey: '0x...',
 *   rpcUrl: 'https://polygon-rpc.com', // optional
 * });
 *
 * // Check if ready for trading
 * const status = await onchain.checkReadyForCTF('100');
 * if (!status.ready) {
 *   // Set up approvals
 *   await onchain.approveAll();
 * }
 *
 * // Execute CTF operations
 * await onchain.split(conditionId, '100');
 * await onchain.merge(conditionId, '100');
 *
 * // Swap tokens
 * await onchain.swap('MATIC', 'USDC_E', '10');
 * ```
 */
import { ethers } from 'ethers';
import { CTFClient, type SplitResult, type MergeResult, type RedeemResult, type PositionBalance, type MarketResolution, type GasEstimate, type TransactionStatus, type TokenIds } from '../clients/ctf-client.js';
import { AuthorizationService, type AllowancesResult, type ApprovalsResult, type ApprovalTxResult } from './authorization-service.js';
import { SwapService, type SwapQuote, type SwapResult, type TokenBalance, type TransferResult, type QuoteResult, type PoolInfo } from './swap-service.js';
export interface OnchainServiceConfig {
    /** Private key for signing transactions */
    privateKey: string;
    /** RPC URL (default: Polygon mainnet) */
    rpcUrl?: string;
    /** Chain ID (default: 137 for Polygon) */
    chainId?: number;
    /** Gas price multiplier for CTF operations (default: 1.2) */
    gasPriceMultiplier?: number;
    /** Transaction confirmation blocks (default: 1) */
    confirmations?: number;
    /** Transaction timeout in ms (default: 60000) */
    txTimeout?: number;
}
export interface ReadyStatus {
    ready: boolean;
    usdcEBalance: string;
    nativeUsdcBalance: string;
    maticBalance: string;
    tradingReady: boolean;
    issues: string[];
    suggestion?: string;
}
export interface TokenBalances {
    matic: string;
    usdc: string;
    usdcE: string;
    usdt: string;
    dai: string;
    weth: string;
    wmatic: string;
}
export type { SplitResult, MergeResult, RedeemResult, PositionBalance, MarketResolution, GasEstimate, TransactionStatus, TokenIds, AllowancesResult, ApprovalsResult, ApprovalTxResult, SwapQuote, SwapResult, TokenBalance, TransferResult, QuoteResult, PoolInfo, };
/**
 * Unified service for all on-chain operations on Polymarket
 *
 * This service wraps:
 * - CTFClient: Conditional Token Framework operations (split, merge, redeem)
 * - AuthorizationService: ERC20 and ERC1155 approvals
 * - SwapService: DEX swaps on Polygon via QuickSwap V3
 *
 * All services share the same wallet and provider configuration.
 */
export declare class OnchainService {
    private wallet;
    private provider;
    private ctfClient;
    private authService;
    private swapService;
    constructor(config: OnchainServiceConfig);
    /**
     * Get the wallet address
     */
    getAddress(): string;
    /**
     * Get native MATIC balance
     */
    getMaticBalance(): Promise<string>;
    /**
     * Get all token balances
     */
    getTokenBalances(): Promise<TokenBalances>;
    /**
     * Check all ERC20 and ERC1155 allowances required for trading
     *
     * @returns Status of all allowances and whether trading is ready
     */
    checkAllowances(): Promise<AllowancesResult>;
    /**
     * Set up all required approvals for trading
     *
     * @returns Results of all approval transactions
     */
    approveAll(): Promise<ApprovalsResult>;
    /**
     * Approve USDC spending for a specific contract
     */
    approveUsdc(spenderAddress: string, amount?: ethers.BigNumber): Promise<ApprovalTxResult>;
    /**
     * Set approval for an ERC1155 operator
     */
    setErc1155Approval(operatorAddress: string, approved?: boolean): Promise<ApprovalTxResult>;
    /**
     * Split USDC into YES + NO tokens
     *
     * @param conditionId - Market condition ID
     * @param amount - USDC amount (e.g., "100" for 100 USDC)
     * @returns SplitResult with transaction details
     */
    split(conditionId: string, amount: string): Promise<SplitResult>;
    /**
     * Merge YES + NO tokens back to USDC
     *
     * @param conditionId - Market condition ID
     * @param amount - Number of token pairs to merge
     * @returns MergeResult with transaction details
     */
    merge(conditionId: string, amount: string): Promise<MergeResult>;
    /**
     * Merge YES and NO tokens using explicit token IDs
     *
     * Use this for Polymarket CLOB markets where token IDs
     * don't match the calculated position IDs.
     */
    mergeByTokenIds(conditionId: string, tokenIds: TokenIds, amount: string): Promise<MergeResult>;
    /**
     * Redeem winning tokens after market resolution (Standard CTF)
     *
     * WARNING: Use redeemByTokenIds for Polymarket CLOB markets.
     */
    redeem(conditionId: string, outcome?: 'YES' | 'NO'): Promise<RedeemResult>;
    /**
     * Redeem winning tokens using Polymarket token IDs (Polymarket CLOB)
     *
     * This is the correct method for Polymarket CLOB markets.
     */
    redeemByTokenIds(conditionId: string, tokenIds: TokenIds, outcome?: 'YES' | 'NO'): Promise<RedeemResult>;
    /**
     * Get USDC.e (bridged USDC) balance - the token used by Polymarket CTF
     */
    getUsdcBalance(): Promise<string>;
    /**
     * Get native USDC balance (not compatible with CTF)
     */
    getNativeUsdcBalance(): Promise<string>;
    /**
     * Get token balances for a market using calculated position IDs
     *
     * @deprecated Use getPositionBalanceByTokenIds for CLOB markets
     */
    getPositionBalance(conditionId: string): Promise<PositionBalance>;
    /**
     * Get token balances using CLOB API token IDs
     *
     * This is the recommended method for checking balances when working with
     * Polymarket CLOB markets.
     */
    getPositionBalanceByTokenIds(conditionId: string, tokenIds: TokenIds): Promise<PositionBalance>;
    /**
     * Check if wallet is ready for CTF trading operations
     *
     * Combines CTF readiness check with authorization status.
     */
    checkReadyForCTF(amount: string): Promise<ReadyStatus>;
    /**
     * Check if wallet has sufficient tokens for merge
     */
    canMerge(conditionId: string, amount: string): Promise<{
        canMerge: boolean;
        reason?: string;
    }>;
    /**
     * Check if wallet has sufficient tokens for merge using CLOB token IDs
     */
    canMergeWithTokenIds(conditionId: string, tokenIds: TokenIds, amount: string): Promise<{
        canMerge: boolean;
        reason?: string;
    }>;
    /**
     * Check if wallet has sufficient USDC for split
     */
    canSplit(amount: string): Promise<{
        canSplit: boolean;
        reason?: string;
    }>;
    /**
     * Check if a market is resolved and get payout info
     */
    getMarketResolution(conditionId: string): Promise<MarketResolution>;
    /**
     * Get detailed gas estimate for a split operation
     */
    estimateSplitGas(conditionId: string, amount: string): Promise<GasEstimate>;
    /**
     * Get detailed gas estimate for a merge operation
     */
    estimateMergeGas(conditionId: string, amount: string): Promise<GasEstimate>;
    /**
     * Get current gas price info
     */
    getGasPrice(): Promise<{
        gwei: string;
        wei: string;
    }>;
    /**
     * Get transaction status with detailed info
     */
    getTransactionStatus(txHash: string): Promise<TransactionStatus>;
    /**
     * Wait for transaction confirmation with timeout
     */
    waitForTransaction(txHash: string, confirmations?: number): Promise<TransactionStatus>;
    /**
     * Get a quote for a swap (checks if route is possible)
     */
    getSwapQuote(tokenIn: string, tokenOut: string, amount: string): Promise<QuoteResult>;
    /**
     * Execute a token swap using QuickSwap V3
     *
     * @param tokenIn - Token to swap from (e.g., 'MATIC', 'USDC', 'USDT')
     * @param tokenOut - Token to swap to (e.g., 'USDC_E', 'WETH')
     * @param amount - Amount to swap in token units
     * @param slippage - Slippage tolerance in percent (default: 0.5)
     */
    swap(tokenIn: string, tokenOut: string, amount: string, slippage?: number): Promise<SwapResult>;
    /**
     * Swap any supported token to USDC.e and deposit to Polymarket
     *
     * This is a convenience method for converting tokens to the USDC.e
     * format required by Polymarket CTF operations.
     */
    swapAndDeposit(token: string, amount: string, slippage?: number): Promise<SwapResult>;
    /**
     * Get all available liquidity pools on QuickSwap V3
     */
    getAvailablePools(): Promise<PoolInfo[]>;
    /**
     * Check if a pool exists for a token pair
     */
    checkPool(tokenA: string, tokenB: string): Promise<PoolInfo>;
    /**
     * Transfer an ERC20 token to another address
     */
    transfer(token: string, to: string, amount: string): Promise<TransferResult>;
    /**
     * Transfer native MATIC to another address
     */
    transferMatic(to: string, amount: string): Promise<TransferResult>;
    /**
     * Transfer native USDC to another address
     *
     * WARNING: This transfers NATIVE USDC, not USDC.e.
     * For Polymarket CTF operations, use transferUsdcE() instead.
     */
    transferUsdc(to: string, amount: string): Promise<TransferResult>;
    /**
     * Transfer USDC.e (bridged USDC) to another address
     *
     * This is the correct method for Polymarket CTF operations.
     */
    transferUsdcE(to: string, amount: string): Promise<TransferResult>;
    /**
     * Wrap native MATIC to WMATIC
     */
    wrapMatic(amount: string): Promise<SwapResult>;
    /**
     * Unwrap WMATIC to native MATIC
     */
    unwrapMatic(amount: string): Promise<SwapResult>;
    /**
     * Get the underlying CTFClient for advanced operations
     */
    getCTFClient(): CTFClient;
    /**
     * Get the underlying AuthorizationService for advanced operations
     */
    getAuthorizationService(): AuthorizationService;
    /**
     * Get the underlying SwapService for advanced operations
     */
    getSwapService(): SwapService;
    /**
     * Get the shared wallet instance
     */
    getWallet(): ethers.Wallet;
    /**
     * Get the shared provider instance
     */
    getProvider(): ethers.providers.JsonRpcProvider;
}
//# sourceMappingURL=onchain-service.d.ts.map